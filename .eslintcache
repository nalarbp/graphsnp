[{"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/index.js":"1","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/App.js":"2","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/configureStore.js":"3","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reportWebVitals.js":"4","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_documentation/main_documentation.js":"5","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_graphsnp/main_graphsnp.js":"6","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/navigation/header.js":"7","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/history.js":"8","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/main_snpDist.js":"9","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_home/main_home.js":"10","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/index.js":"11","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_documentation/comp_about.js":"12","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_documentation/comp_inputFiles.js":"13","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_documentation/comp_extra.js":"14","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_graphsnp/comp_metadataBox.js":"15","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_graphsnp/comp_graphContainer.js":"16","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/navigation/navigation.js":"17","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/navigationActions.js":"18","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_graphsnp/comp_sider.js":"19","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_snpDist_settings.js":"20","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_home/comp_selectDemoData.js":"21","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_snpDist_viewer.js":"22","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_home/comp_inputPlaceholder.js":"23","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_home/comp_footer.js":"24","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/img/circle.js":"25","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/projectsReducer.js":"26","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/sequenceReducer.js":"27","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/navSettingsReducer.js":"28","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/graphSettingsReducer.js":"29","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/metadataReducer.js":"30","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/patientMovementReducer.js":"31","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/isInputLoadingReducer.js":"32","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/graphObjectReducer.js":"33","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/hammMatrixReducer.js":"34","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/graphClustersReducer.js":"35","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/colorLUTReducer.js":"36","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/categoricalMapReducer.js":"37","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/selectDemoDataReducer.js":"38","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/snpDistSettingsReducer.js":"39","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/selectedNodeReducer.js":"40","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/isShowingLoadingModalReducer.js":"41","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/constants.js":"42","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/graphSettingsActions.js":"43","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/colorActions.js":"44","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/create_graphObject.js":"45","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/create_cyData.js":"46","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/create_exportFile.js":"47","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/find_clusters.js":"48","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/utils.js":"49","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/graphMatrixActions.js":"50","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/isShowingLoadingModalActions.js":"51","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/model/hammingMatrix_prop.js":"52","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/categoricalMapActions.js":"53","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/inputActions.js":"54","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_home/util_home.js":"55","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/snpdistSettingsActions.js":"56","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/model/distanceMatrix_prop.js":"57","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/construct_mscg.js":"58","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/construct_seqtrack.js":"59","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/cluster_louvain.js":"60","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/cluster_fcc.js":"61","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/model/graphEdgeList_prop.js":"62","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/construct_smso.js":"63","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/construct_cge.js":"64","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/construct_cathai.js":"65","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/construct_mcg.js":"66","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/chart_barplot_all.js":"67","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/model/stayList_prop.js":"68","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_select_samples.js":"69","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/util_snpDist.js":"70","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_snpDist_bar.js":"71","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_select_charts.js":"72","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_snpDist_drawCharts.js":"73","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_snpDist_boxplot.js":"74"},{"size":663,"mtime":1610195666000,"results":"75","hashOfConfig":"76"},{"size":1045,"mtime":1612155926000,"results":"77","hashOfConfig":"76"},{"size":477,"mtime":1610107486000,"results":"78","hashOfConfig":"76"},{"size":362,"mtime":1610086392000,"results":"79","hashOfConfig":"76"},{"size":970,"mtime":1628782168000,"results":"80","hashOfConfig":"76"},{"size":1481,"mtime":1660145055481,"results":"81","hashOfConfig":"76"},{"size":626,"mtime":1660042377096,"results":"82","hashOfConfig":"76"},{"size":88,"mtime":1610155012000,"results":"83","hashOfConfig":"76"},{"size":2490,"mtime":1660161669518,"results":"84","hashOfConfig":"76"},{"size":1814,"mtime":1660018709190,"results":"85","hashOfConfig":"76"},{"size":3193,"mtime":1660155183937,"results":"86","hashOfConfig":"76"},{"size":2717,"mtime":1652678360000,"results":"87","hashOfConfig":"76"},{"size":1845,"mtime":1652677471000,"results":"88","hashOfConfig":"76"},{"size":2903,"mtime":1652677413000,"results":"89","hashOfConfig":"76"},{"size":3841,"mtime":1656410157533,"results":"90","hashOfConfig":"76"},{"size":20998,"mtime":1644836775000,"results":"91","hashOfConfig":"76"},{"size":2634,"mtime":1633421033000,"results":"92","hashOfConfig":"76"},{"size":159,"mtime":1611887099000,"results":"93","hashOfConfig":"76"},{"size":29173,"mtime":1659885895291,"results":"94","hashOfConfig":"76"},{"size":4637,"mtime":1660155813796,"results":"95","hashOfConfig":"76"},{"size":3496,"mtime":1660057948552,"results":"96","hashOfConfig":"76"},{"size":8862,"mtime":1660145621350,"results":"97","hashOfConfig":"76"},{"size":7445,"mtime":1660056548092,"results":"98","hashOfConfig":"76"},{"size":991,"mtime":1660030524465,"results":"99","hashOfConfig":"76"},{"size":571,"mtime":1633671995000,"results":"100","hashOfConfig":"76"},{"size":386,"mtime":1644300732000,"results":"101","hashOfConfig":"76"},{"size":378,"mtime":1610108902000,"results":"102","hashOfConfig":"76"},{"size":584,"mtime":1610154547000,"results":"103","hashOfConfig":"76"},{"size":6013,"mtime":1644835424000,"results":"104","hashOfConfig":"76"},{"size":379,"mtime":1612088497000,"results":"105","hashOfConfig":"76"},{"size":405,"mtime":1613173279000,"results":"106","hashOfConfig":"76"},{"size":401,"mtime":1610683140000,"results":"107","hashOfConfig":"76"},{"size":391,"mtime":1611809625000,"results":"108","hashOfConfig":"76"},{"size":390,"mtime":1611802301000,"results":"109","hashOfConfig":"76"},{"size":396,"mtime":1611822589000,"results":"110","hashOfConfig":"76"},{"size":379,"mtime":1611887208000,"results":"111","hashOfConfig":"76"},{"size":408,"mtime":1612088419000,"results":"112","hashOfConfig":"76"},{"size":404,"mtime":1628788106000,"results":"113","hashOfConfig":"76"},{"size":3377,"mtime":1660155262719,"results":"114","hashOfConfig":"76"},{"size":395,"mtime":1628876227000,"results":"115","hashOfConfig":"76"},{"size":415,"mtime":1629784335000,"results":"116","hashOfConfig":"76"},{"size":3890,"mtime":1660154857726,"results":"117","hashOfConfig":"76"},{"size":2898,"mtime":1644835462000,"results":"118","hashOfConfig":"76"},{"size":220,"mtime":1611889589000,"results":"119","hashOfConfig":"76"},{"size":2478,"mtime":1637596105000,"results":"120","hashOfConfig":"76"},{"size":2068,"mtime":1634260809000,"results":"121","hashOfConfig":"76"},{"size":1945,"mtime":1631767380000,"results":"122","hashOfConfig":"76"},{"size":618,"mtime":1637596264000,"results":"123","hashOfConfig":"76"},{"size":8094,"mtime":1660157906314,"results":"124","hashOfConfig":"76"},{"size":452,"mtime":1611822450000,"results":"125","hashOfConfig":"76"},{"size":190,"mtime":1629784386000,"results":"126","hashOfConfig":"76"},{"size":3248,"mtime":1633593375000,"results":"127","hashOfConfig":"76"},{"size":250,"mtime":1612088403000,"results":"128","hashOfConfig":"76"},{"size":725,"mtime":1644300780000,"results":"129","hashOfConfig":"76"},{"size":10629,"mtime":1660160986912,"results":"130","hashOfConfig":"76"},{"size":1556,"mtime":1660154860460,"results":"131","hashOfConfig":"76"},{"size":3110,"mtime":1644829288000,"results":"132","hashOfConfig":"76"},{"size":4987,"mtime":1644836909000,"results":"133","hashOfConfig":"76"},{"size":7572,"mtime":1647499268000,"results":"134","hashOfConfig":"76"},{"size":1301,"mtime":1633424001000,"results":"135","hashOfConfig":"76"},{"size":4437,"mtime":1634890099000,"results":"136","hashOfConfig":"76"},{"size":1759,"mtime":1628134710000,"results":"137","hashOfConfig":"76"},{"size":7607,"mtime":1628825042000,"results":"138","hashOfConfig":"76"},{"size":2295,"mtime":1628744407000,"results":"139","hashOfConfig":"76"},{"size":975,"mtime":1628743494000,"results":"140","hashOfConfig":"76"},{"size":2742,"mtime":1629170912000,"results":"141","hashOfConfig":"76"},{"size":7049,"mtime":1632464914000,"results":"142","hashOfConfig":"76"},{"size":1413,"mtime":1613285314000,"results":"143","hashOfConfig":"76"},{"size":6103,"mtime":1660138288826,"results":"144","hashOfConfig":"76"},{"size":1264,"mtime":1660185657684,"results":"145","hashOfConfig":"76"},{"size":759,"mtime":1660161033856,"results":"146","hashOfConfig":"76"},{"size":3750,"mtime":1660154345960,"results":"147","hashOfConfig":"76"},{"size":2127,"mtime":1660162324096,"results":"148","hashOfConfig":"76"},{"size":789,"mtime":1660162939790,"results":"149","hashOfConfig":"76"},{"filePath":"150","messages":"151","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},"1bmlf9h",{"filePath":"153","messages":"154","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"155","messages":"156","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"157","messages":"158","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"159","messages":"160","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"161","messages":"162","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"163","messages":"164","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"165","messages":"166","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"167","messages":"168","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"169","messages":"170","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"171","messages":"172","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"173","messages":"174","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"175","messages":"176","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"177","usedDeprecatedRules":"152"},{"filePath":"178","messages":"179","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"180","messages":"181","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"182","usedDeprecatedRules":"152"},{"filePath":"183","messages":"184","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"185","usedDeprecatedRules":"152"},{"filePath":"186","messages":"187","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"188","messages":"189","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"190","messages":"191","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"192","usedDeprecatedRules":"152"},{"filePath":"193","messages":"194","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"195","messages":"196","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"197","usedDeprecatedRules":"152"},{"filePath":"198","messages":"199","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"200","messages":"201","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"202","messages":"203","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"204","messages":"205","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"206","messages":"207","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"208","messages":"209","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"210","messages":"211","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"212","messages":"213","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"214","messages":"215","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"216","messages":"217","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"218","messages":"219","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"220","messages":"221","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"222","messages":"223","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"224","messages":"225","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"226","messages":"227","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"228","messages":"229","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"230","messages":"231","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"232","messages":"233","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"234","messages":"235","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"236","messages":"237","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"238","messages":"239","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"240","messages":"241","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"242","messages":"243","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"244","messages":"245","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"246","messages":"247","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"248","messages":"249","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"250","messages":"251","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"252","messages":"253","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"254","messages":"255","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"256","messages":"257","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"258","messages":"259","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"260","messages":"261","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"262","messages":"263","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"264","messages":"265","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"266","messages":"267","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"268","messages":"269","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"270","messages":"271","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"272","usedDeprecatedRules":"152"},{"filePath":"273","messages":"274","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"275","usedDeprecatedRules":"152"},{"filePath":"276","messages":"277","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"278","messages":"279","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"280","messages":"281","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"282","messages":"283","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"284","usedDeprecatedRules":"152"},{"filePath":"285","messages":"286","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"287","messages":"288","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"289","messages":"290","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"291","messages":"292","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"293","messages":"294","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"295","messages":"296","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"152"},{"filePath":"297","messages":"298","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"299","messages":"300","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"301","messages":"302","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"303","messages":"304","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"305","messages":"306","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/index.js",[],["307","308"],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/App.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/configureStore.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reportWebVitals.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_documentation/main_documentation.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_graphsnp/main_graphsnp.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/navigation/header.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/history.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/main_snpDist.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_home/main_home.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/index.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_documentation/comp_about.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_documentation/comp_inputFiles.js",["309"],"import React from \"react\";\nimport { Typography, Divider, Button } from \"antd\";\nimport * as constant from \"../utils/constants\";\nimport \"./style_documentation.css\";\n\nconst { Title, Paragraph, Text } = Typography;\n\nconst InputFiles = (props) => {\n  return (\n    <React.Fragment>\n      <div className=\"graphsnp-docs-content\">\n        <Title level={2} underline>\n          {\" \"}\n          Input file(s){\" \"}\n        </Title>\n        <Title level={3}>A multi-fasta SNPs alignment</Title>\n        <Text>\n          SNPs alignment file must contain at least two equally length of\n          fasta-formatted non-gap nucleotide sequences.\n        </Text>\n        <br />\n        <br />\n        <Button type={\"primary\"} href={constant.TEMPLATE.snps}>\n          Download a SNPs alignment example file\n        </Button>\n        <br />\n        <br />\n        <Title level={3}>A distance matrix</Title>\n        <Text>\n          User can also input the pairwise distances matrix instead of SNP\n          alignment. The symmetric matrix should be written in comma-separated\n          value (CSV) format.\n        </Text>\n        <br />\n        <br />\n        <Button type={\"primary\"} href={constant.TEMPLATE.distanceMatrix}>\n          Download a distance matrix example file\n        </Button>\n        <br />\n        <br />\n\n        <Title level={3}>Metadata table</Title>\n        <Text>\n          Metadata table must contain at least one non-empty column of\n          sample_id. Sample identifier must be identical on both metadata and\n          SNPs alignment or matrix.\n        </Text>\n        <br />\n        <br />\n        <Button type={\"primary\"} href={constant.TEMPLATE.metadata}>\n          Download a metadata example file\n        </Button>\n        <br />\n        <br />\n      </div>\n      <Divider />\n    </React.Fragment>\n  );\n};\n\nexport default InputFiles;\n","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_documentation/comp_extra.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_graphsnp/comp_metadataBox.js",["310","311","312"],"import React, { useState, useEffect } from \"react\";\nimport { Row, Col, Collapse, Table } from \"antd\";\nimport { TableOutlined } from \"@ant-design/icons\";\nimport { connect } from \"react-redux\";\nimport { bindActionCreators } from \"redux\";\nimport Moment from \"moment\";\nimport { extendMoment } from \"moment-range\";\nimport { changeSelectedNode } from \"../action/graphSettingsActions\";\n\nconst { Panel } = Collapse;\nconst moment = extendMoment(Moment);\nconst MetadataBox = (props) => {\n  //STATES\n  const [dataTable, setdataTable] = useState({\n    columns: null,\n    cells: null,\n  });\n\n  const lala = \"ll,egka\";\n\n  //USEEFFECTS\n  useEffect(() => {\n    if (props.metadata) {\n      //console.log(props.selectedNode);\n      if (props.selectedNode.length >= 1) {\n        //console.log(props.selectedNode);\n        let selectedNodeList = [];\n        props.selectedNode.forEach((n) => {\n          if (props.metadata.get(n)) {\n            selectedNodeList.push(props.metadata.get(n));\n          }\n        });\n\n        if (selectedNodeList.length >= 1) {\n          let columns = [];\n          Object.keys(selectedNodeList[0]).forEach((d, idx) => {\n            columns.push({\n              title: d,\n              dataIndex: d,\n              key: d + idx.toString(),\n            });\n          });\n\n          selectedNodeList.forEach((d, idx) => {\n            d[\"key\"] = idx;\n          });\n          //console.log(columns, dataSource);\n\n          //clear up columns\n          let columns_filtered = columns.filter((c) => {\n            console.log(c.dataIndex);\n            if (c.dataIndex.includes(\":color\") || c.dataIndex.includes(\"key\")) {\n              return false;\n            } else {\n              return true;\n            }\n          });\n\n          setdataTable({\n            columns: columns_filtered,\n            cells: selectedNodeList,\n          });\n        } else {\n          setdataTable({\n            columns: null,\n            cells: null,\n          });\n        }\n      } else {\n        setdataTable({\n          columns: null,\n          cells: null,\n        });\n      }\n    }\n  }, [props.selectedNode]);\n\n  return (\n    <React.Fragment>\n      <div id=\"metadata-box\">\n        {props.metadata && props.graphObject && (\n          <Row style={{ paddingBottom: \"0px\" }}>\n            <Col span={24}>\n              <Collapse accordion bordered={false} expandIconPosition=\"left\">\n                <Panel\n                  style={{\n                    marginBottom: \"0px\",\n                    textAlign: \"left\",\n                    overflowY: \"auto\",\n                  }}\n                  header={\n                    <p style={{ marginBottom: \"0px\" }}>\n                      <TableOutlined /> Selected node metadata\n                    </p>\n                  }\n                  key=\"1\"\n                >\n                  {props.selectedNode &&\n                    props.graphObject &&\n                    dataTable.columns && (\n                      <Table\n                        size=\"small\"\n                        pagination={false}\n                        style={{ width: \"100%\" }}\n                        dataSource={dataTable.cells}\n                        columns={dataTable.columns}\n                      />\n                    )}\n\n                  {!props.selectedNode && <p>No selected node</p>}\n                </Panel>\n              </Collapse>\n            </Col>\n          </Row>\n        )}\n      </div>\n    </React.Fragment>\n  );\n};\n\nfunction mapStateToProps(state) {\n  return {\n    metadata: state.metadata,\n    colorLUT: state.colorLUT,\n    selectedNode: state.selectedNode,\n    graphObject: state.graphObject,\n  };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return bindActionCreators(\n    {\n      changeSelectedNode,\n    },\n    dispatch\n  );\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MetadataBox);\n\n/*\n\n*/\n","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_graphsnp/comp_graphContainer.js",["313","314","315","316","317","318","319","320","321","322","323","324"],"/*\n- Comp init => render => all useEffect\n- loading wont work using states, use indicator on draw button instead\n- All useEffect called when first loaded (eg: from Home to graphSNP page)\n- certain useEffect called when any deppendent useEffect affected\n*/\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { connect } from \"react-redux\";\nimport { bindActionCreators } from \"redux\";\nimport { colorLUTtoStore } from \"../action/colorActions\";\nimport { Col, Empty, Button, message } from \"antd\";\nimport { createGraphObject } from \"../utils/create_graphObject\";\nimport { createCytoscapeData } from \"../utils/create_cyData\";\nimport { createClusterCSVFile } from \"../utils/create_exportFile\";\nimport { cricle_svgUrl } from \"../img/circle.js\";\nimport { findClusters } from \"../utils//find_clusters\";\nimport cytoscape from \"cytoscape\";\nimport cy_svg from \"cytoscape-svg\";\nimport { LoadingOutlined, ReloadOutlined } from \"@ant-design/icons\";\nimport {\n  createColorLUT,\n  getColorByColorIndex,\n  getEdgeAndArrowWidth,\n  downloadFileAsText,\n} from \"../utils/utils\";\nimport HammingMatrix from \"../model/hammingMatrix_prop\";\nimport {\n  hmmMatrixToStore,\n  graphObjectToStore,\n  graphClusterToStore,\n} from \"../action/graphMatrixActions\";\nimport {\n  changeIsUserReDrawSetting,\n  changeIsUserClusteringSetting,\n  changeIsUserDownloadingSetting,\n  changeChartSessionSetting,\n  changeIsUserLoadSessionSetting,\n  changeSelectedNode,\n  changeIsUserRelayoutSetting,\n} from \"../action/graphSettingsActions\";\nimport isShowingLoadingModalToStore from \"../action/isShowingLoadingModalActions\";\nimport coseBilkent from \"cytoscape-cose-bilkent\";\n\nconst _ = require(\"lodash\");\nconst fcose = require(\"cytoscape-fcose\");\nconst spread = require(\"cytoscape-spread\");\nconst dagre = require(\"cytoscape-dagre\");\n\ncytoscape.use(coseBilkent); // register extension\ncytoscape.use(fcose); // register extension\ncytoscape.use(spread); // register extension\ncytoscape.use(cy_svg); // register extension\ncytoscape.use(dagre); // register extension\n\nconst GraphContainer = (props) => {\n  //state\n  const [graphIsAvailable, setGraphIsAvailable] = useState(false);\n  const [processingGraph, setProcessingGraph] = useState(false);\n\n  //Settings\n  const graph_typeOfAnalysis = props.graphSettings.typeOfAnalysis;\n  const graph_method = props.graphSettings.method;\n  const graph_layout = props.graphSettings.layout;\n  const graph_isUserReDraw = props.graphSettings.isUserReDraw;\n  const graph_isUserFilterEdges = props.graphSettings.isUserFilteringEdge;\n  const graph_edgeFilterCutoff = graph_isUserFilterEdges\n    ? props.graphSettings.edgeFilterCutoff\n    : null;\n  const graph_clusterMethod = props.graphSettings.clusterMethod;\n  const graph_isUserClustering = props.graphSettings.isUserClustering;\n  const graph_isEdgesHideByCutoff = props.graphSettings.isHideEdgesByCutoff;\n  const graph_edgesHideCutoff = props.graphSettings.hiddenEdgesCutoff;\n  const graph_colorNodeBy = props.graphSettings.colorNodedBy;\n  const graph_isEdgeScaled = props.graphSettings.isEdgeScaled;\n  const graph_edgeScaleFactor = props.graphSettings.edgeScaleFactor;\n  const graph_isUserDownloading = props.graphSettings.isUserDownloading;\n  const trans_locLevel = props.graphSettings.transIncludeLocLevel;\n  const graph_isUserRelayout = props.graphSettings.isUserRelayout;\n  const graph_node_isLabelShown = props.graphSettings.node_isLabelShown;\n  const graph_edge_labelSize = props.graphSettings.edge_labelSize;\n\n  //Internal setting\n  const cy_layout = { name: graph_layout, animate: false, fit: true };\n  const cytoscapeRef = useRef(null);\n  const prevSessionData = props.graphSettings.chartSession;\n  const isUserReloadSession = props.graphSettings.isUserReloadSession;\n\n  //Cytoscape default settings\n  const node_size = 6;\n  const node_size_margin = 1;\n  const node_size_sel = 8;\n  const node_label_size = \"6px\";\n\n  //Automatic reloading if previous graph session data is a available\n\n  useEffect(() => {\n    if (graph_isUserReDraw) {\n      //console.log(\"1. START: user click draw ##\", +new Date());\n      //setProcessingGraph(true); // set time out to delay drawing and let processing graph state run\n\n      setTimeout(function () {\n        //console.log(\"2. setTimeout start and draw start ##\", +new Date());\n        draw();\n        //console.log(\"8. Draw end in setTimeout ##\", +new Date());\n        setGraphIsAvailable(true);\n        //setProcessingGraph(false);\n        props.changeIsUserReDrawSetting(false);\n        props.isShowingLoadingModalToStore(false);\n        //console.log(\"9. SetTimeout end ##\", +new Date());\n      }, 100);\n    }\n  }, [graph_isUserReDraw]);\n\n  useEffect(() => {\n    if (isUserReloadSession) {\n      //setProcessingGraph(true);\n      setTimeout(() => {\n        redraw();\n        setGraphIsAvailable(true);\n        //setProcessingGraph(false);\n        props.changeIsUserLoadSessionSetting(false);\n        props.isShowingLoadingModalToStore(false);\n      }, 100);\n    }\n  }, [isUserReloadSession]);\n\n  useEffect(() => {\n    if (graph_isUserDownloading) {\n      let cy = cytoscapeRef.current;\n      let svgContent = cy.svg({ scale: 1, full: true });\n      downloadFileAsText(\"GraphSNP-cytoscape-svg.svg\", svgContent);\n      props.changeIsUserDownloadingSetting(false);\n    }\n  }, [graph_isUserDownloading]);\n\n  useEffect(() => {\n    if (graph_isUserClustering && props.graphObject) {\n      setProcessingGraph(true);\n      setTimeout(function () {\n        //call clustering\n        let clusters = findClusters(props.graphObject, graph_clusterMethod);\n        //console.log(props.graphObject);\n        setProcessingGraph(false);\n        message.success(\n          `Found ${clusters.group.length} clusters in the graph`,\n          2\n        );\n        //update colorLUT by new clusters color\n        let colorLUT_byCluster = createColorLUT(clusters.members, \"clusterID\");\n        let newColorLUT = _.cloneDeep(props.colorLUT);\n        if (newColorLUT) {\n          let updated_newColorLUT = {\n            ...newColorLUT,\n            clusterID: colorLUT_byCluster,\n          };\n          newColorLUT = updated_newColorLUT;\n        } else {\n          newColorLUT = { clusterID: colorLUT_byCluster };\n        }\n        props.colorLUTtoStore(newColorLUT);\n\n        props.graphClusterToStore(clusters);\n        props.changeIsUserClusteringSetting(false);\n      }, 100);\n    }\n  }, [graph_clusterMethod, graph_isUserClustering]);\n\n  useEffect(() => {\n    if (graph_isUserRelayout && cytoscapeRef.current) {\n      setTimeout(() => {\n        let cy = cytoscapeRef.current;\n        let layout = {\n          name: graph_layout,\n          animate: false,\n          fit: true,\n          prelayout: false,\n        };\n        cy.layout(layout).run();\n        cytoscapeRef.current = cy;\n        props.isShowingLoadingModalToStore(false);\n        props.changeIsUserRelayoutSetting(false);\n      }, 100);\n    }\n  }, [graph_isUserRelayout]);\n\n  useEffect(() => {\n    if (props.graphObject && cytoscapeRef.current) {\n      let cy = cytoscapeRef.current;\n      if (graph_isEdgeScaled) {\n        cy.style()\n          .selector(\"edge\")\n          .style({\n            width: function (e) {\n              return getEdgeAndArrowWidth(\n                graph_isEdgeScaled,\n                e.data(\"weight\"),\n                graph_edgeScaleFactor,\n                \"edge\"\n              );\n            },\n            \"arrow-scale\": function (e) {\n              return getEdgeAndArrowWidth(\n                graph_isEdgeScaled,\n                e.data(\"weight\"),\n                graph_edgeScaleFactor,\n                \"arrow\"\n              );\n            },\n          })\n          .update();\n        cytoscapeRef.current = cy;\n      } else {\n        cy.style()\n          .selector(\"edge\")\n          .style({\n            width: 3,\n            \"arrow-scale\": 1,\n          })\n          .update();\n        cytoscapeRef.current = cy;\n      }\n    }\n  }, [graph_isEdgeScaled, graph_edgeScaleFactor]);\n\n  useEffect(() => {\n    if (props.graphObject && cytoscapeRef.current) {\n      let cy = cytoscapeRef.current;\n      if (graph_isEdgesHideByCutoff) {\n        cy.style()\n          .selector(\"edge\")\n          .style({\n            opacity: function (o) {\n              let edgeWeight = o.data(\"weight\");\n              if (graph_isEdgesHideByCutoff) {\n                let res =\n                  edgeWeight < graph_edgesHideCutoff.min ||\n                  edgeWeight > graph_edgesHideCutoff.max\n                    ? 0\n                    : 1;\n                return res;\n              } else {\n                return 1;\n              }\n            },\n          })\n          .update();\n        cytoscapeRef.current = cy;\n      } else {\n        cy.style()\n          .selector(\"edge\")\n          .style({\n            opacity: 1,\n          })\n          .update();\n        cytoscapeRef.current = cy;\n      }\n      cytoscapeRef.current = cy;\n    }\n  }, [graph_isEdgesHideByCutoff, graph_edgesHideCutoff]);\n\n  useEffect(() => {\n    if (graph_colorNodeBy && props.colorLUT && cytoscapeRef.current) {\n      let cy = cytoscapeRef.current;\n      cy.style()\n        .selector(\"node\")\n        .style({\n          \"background-color\": function (d) {\n            let isolate_name = d.data(\"id\");\n            let col = getColorByColorIndex(\n              isolate_name,\n              graph_colorNodeBy,\n              props.colorLUT\n            );\n            return col;\n          },\n        })\n        .update();\n\n      cytoscapeRef.current = cy;\n    }\n  }, [graph_colorNodeBy, props.colorLUT]);\n\n  useEffect(() => {\n    if (cytoscapeRef.current) {\n      let cy = cytoscapeRef.current;\n      if (graph_node_isLabelShown) {\n        cy.style()\n          .selector(\"node\")\n          .style({ \"font-size\": node_label_size })\n          .update();\n      } else {\n        cy.style().selector(\"node\").style({ \"font-size\": \"0px\" }).update();\n      }\n      cytoscapeRef.current = cy;\n    }\n  }, [graph_node_isLabelShown]);\n\n  useEffect(() => {\n    if (cytoscapeRef.current) {\n      let cy = cytoscapeRef.current;\n      cy.style()\n        .selector(\"edge\")\n        .style({ \"font-size\": String(graph_edge_labelSize) + \"px\" })\n        .update();\n      cytoscapeRef.current = cy;\n    }\n  }, [graph_edge_labelSize]);\n\n  useEffect(() => {\n    if (props.selectedNode && cytoscapeRef.current) {\n      let cy = cytoscapeRef.current;\n      if (props.selectedNode.length >= 1) {\n        props.selectedNode.forEach((n) => {\n          cy.filter(`node[id = \"${n}\"]`).select();\n        });\n      } else {\n        cy.filter(\"node\").unselect();\n      }\n\n      cytoscapeRef.current = cy;\n    }\n  }, [props.selectedNode]);\n\n  const reloadChartHandler = (val) => {\n    if (!isUserReloadSession) {\n      props.isShowingLoadingModalToStore(true);\n      props.changeIsUserLoadSessionSetting(true);\n    }\n  };\n\n  //DRAW\n  function draw() {\n    //console.log(\"drawww\", props.selectedNode);\n    //console.log(\"3. Start drawing, creating hammingMatrix ##\", +new Date());\n    //check hamming distance ? if not create one, send to store at the end.\n    const hammingMatrix = !props.hammMatrix\n      ? new HammingMatrix(props.sequence).getHammingMatrix()\n      : props.hammMatrix;\n\n    const seq_len = props.sequence ? props.sequence[0].size : null;\n\n    //Look at param (method, seq, ), generate graph object: util functions\n    //graphObject: {type:'mcg', mapData: edgeList object}\n    //console.log(\"4. Creating graph object ##\", +new Date());\n\n    const graphObject = createGraphObject(\n      hammingMatrix,\n      graph_method,\n      graph_edgeFilterCutoff,\n      props.categoricalMap,\n      props.patientMovement,\n      props.metadata,\n      trans_locLevel,\n      seq_len\n    );\n\n    //generate cytoscape data\n    if (graphObject && graphObject.nodes && graphObject.edges) {\n      //cytoscapeData = [{data:{id:id, nodeType:'singleton', data:[]}}, { data: {source: s, target: t, weight: w} } ]\n      //console.log(\"5. Creating cytoscape data ##\", +new Date());\n      const cytoscapeData = createCytoscapeData(graphObject);\n\n      //Load and view cytoscape\n      if (cytoscapeData) {\n        //console.log(\"6. Cytoscape data mapping ##\", +new Date());\n        if (prevSessionData) {\n          let cy = prevSessionData;\n          cy.unmount();\n        }\n\n        const cy = cytoscape({\n          elements: cytoscapeData,\n          container: document.getElementById(\"graph-cont-cytoscape-canvas\"),\n          pannable: true,\n          selected: true,\n          boxSelectionEnabled: false,\n          style: [\n            {\n              selector: \"node\",\n              style: {\n                shape: graph_method === \"mscg\" ? \"round-rectangle\" : \"circle\",\n                width: function (d) {\n                  let nodeData = d.data(\"data\");\n                  if (nodeData && nodeData.size) {\n                    return (node_size + node_size_margin) * nodeData.size;\n                  } else {\n                    return node_size;\n                  }\n                },\n                height: function (d) {\n                  let nodeData = d.data(\"data\");\n                  if (nodeData && nodeData.size) {\n                    return (node_size + node_size_margin) * nodeData.size;\n                  } else {\n                    return node_size;\n                  }\n                },\n                label: \"data(id)\",\n                \"text-wrap\": \"none\",\n                \"text-valign\": function (d) {\n                  let nodeData = d.data(\"data\");\n                  if (nodeData && nodeData.size) {\n                    return \"center\";\n                  } else {\n                    return \"top\";\n                  }\n                },\n                \"font-size\": node_label_size,\n                \"border-width\": 1,\n                \"border-style\": \"solid\",\n                \"border-color\": \"black\",\n                \"background-color\": function (d) {\n                  if (graph_colorNodeBy && props.colorLUT) {\n                    let isolate_name = d.data(\"id\");\n                    let col = getColorByColorIndex(\n                      isolate_name,\n                      graph_colorNodeBy,\n                      props.colorLUT\n                    );\n                    return col;\n                  } else {\n                    return \"lightgray\";\n                  }\n                },\n              },\n            },\n            {\n              selector: \":parent\",\n              shape: \"round-rectangle\",\n              style: {\n                \"background-image\": \"none\",\n                \"padding-top\": \"5px\",\n                \"background-position-x\": \"0\",\n                \"background-position-y\": \"0\",\n                \"background-width\": \"100%\",\n                \"background-height\": \"100%\",\n                \"background-fit\": \"contain\",\n                \"background-opacity\": \"0\",\n                \"border-width\": \"1\",\n                \"text-valign\": \"top\",\n                \"text-halign\": \"center\",\n              },\n            },\n            {\n              selector: \"edge\",\n              style: {\n                opacity: function (o) {\n                  let edgeWeight = o.data(\"weight\");\n                  //console.log(edgeWeight);\n                  if (graph_isEdgesHideByCutoff) {\n                    let res =\n                      edgeWeight < graph_edgesHideCutoff.min ||\n                      edgeWeight > graph_edgesHideCutoff.max\n                        ? 0\n                        : 1;\n                    return res;\n                  } else {\n                    return 1;\n                  }\n                },\n                label: \"data(weight)\",\n                \"font-size\": String(graph_edge_labelSize) + \"px\",\n                \"text-background-color\": \"#F5E372\",\n                color: \"red\",\n                width: function (e) {\n                  return getEdgeAndArrowWidth(\n                    graph_isEdgeScaled,\n                    e.data(\"weight\"),\n                    graph_edgeScaleFactor,\n                    \"edge\"\n                  );\n                },\n                \"target-arrow-color\": \"black\",\n                \"target-arrow-shape\": (e) => {\n                  return e.data(\"dir\") === \"forward\" ? \"triangle\" : \"none\";\n                },\n                \"curve-style\": \"bezier\",\n                \"arrow-scale\": function (e) {\n                  return getEdgeAndArrowWidth(\n                    graph_isEdgeScaled,\n                    e.data(\"weight\"),\n                    graph_edgeScaleFactor,\n                    \"arrow\"\n                  );\n                },\n              },\n            },\n            {\n              selector: \":selected\",\n              style: {\n                \"border-width\": 2,\n                \"border-color\": \"red\",\n                \"border-style\": \"double\",\n              },\n            },\n          ],\n        });\n\n        if (graph_layout === \"spread\") {\n          let diverted_layout = {\n            name: \"cose\",\n            animate: false,\n            fit: true,\n            prelayout: false,\n          };\n\n          cy.layout(diverted_layout).run();\n        } else {\n          //console.log(\"7. Cytoscape running with layout ##\", +new Date());\n          cy.layout(cy_layout).run();\n        }\n        //node event click listener\n        cy.selectionType(\"single\");\n        cy.nodes().bind(\"tap\", function (evt) {\n          let nodeData = evt.target.data(\"data\");\n          let nodeId =\n            nodeData && nodeData.size\n              ? nodeData.contents\n              : [evt.target.data(\"id\")]; //always return arr\n          let prev_selected_nodes = cy\n            .elements(\"node:selected\")\n            .map((d) => (d ? d.id() : null)); // always return empty arr or with id(s)\n          //let current_selected_nodes = prev_selected_nodes.concat(nodeId);\n          props.changeSelectedNode(nodeId);\n        });\n        //click on background listener\n        cy.on(\"tap\", function (evt) {\n          if (evt.target === cy) {\n            props.changeSelectedNode([]);\n          }\n        });\n        //cy.layout(cy_layout).run();\n        //save current Ref\n        //save current Ref\n        cytoscapeRef.current = cy;\n\n        //==== SEND TO STORE ====\n        if (props.hammMatrix) {\n          props.hmmMatrixToStore(hammingMatrix);\n        }\n        props.graphObjectToStore(graphObject);\n        props.changeChartSessionSetting(cy);\n      }\n    }\n  }\n  function redraw() {\n    let cy = prevSessionData;\n    cy.unmount();\n    cy.mount(document.getElementById(\"graph-cont-cytoscape-canvas\"));\n    cytoscapeRef.current = cy;\n  }\n\n  return (\n    <React.Fragment>\n      <Col span={24} style={{ position: \"relative\" }}>\n        <div\n          id=\"graph-cont-is-empty\"\n          style={{ display: graphIsAvailable ? \"none\" : \"block\" }}\n        >\n          <Empty\n            description={\n              prevSessionData ? \"Reload previous graph\" : \"No graph. Create one\"\n            }\n            image={Empty.PRESENTED_IMAGE_SIMPLE}\n          >\n            {prevSessionData && (\n              <Button onClick={reloadChartHandler} type=\"primary\">\n                <ReloadOutlined />\n              </Button>\n            )}\n          </Empty>\n        </div>\n        <div\n          id=\"graph-cont-is-processing\"\n          style={{ display: processingGraph ? \"block\" : \"none\" }}\n        >\n          <p\n            style={{\n              textAlign: \"right\",\n            }}\n          >\n            <span>\n              <LoadingOutlined\n                style={{\n                  fontSize: 18,\n                }}\n                spin\n              />\n            </span>{\" \"}\n            Creating graph ...\n          </p>\n        </div>\n      </Col>\n      <div id=\"graph-cont-cytoscape-canvas\"></div>\n    </React.Fragment>\n  );\n};\n\nfunction mapStateToProps(state) {\n  return {\n    metadata: state.metadata,\n    patientMovement: state.patientMovement,\n    sequence: state.sequence,\n    graphObject: state.graphObject,\n    hammMatrix: state.hammMatrix,\n    graphSettings: state.graphSettings,\n    colorLUT: state.colorLUT,\n    graphClusters: state.graphClusters,\n    categoricalMap: state.categoricalMap,\n    selectedNode: state.selectedNode,\n  };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return bindActionCreators(\n    {\n      changeIsUserClusteringSetting,\n      changeIsUserReDrawSetting,\n      hmmMatrixToStore,\n      graphObjectToStore,\n      graphClusterToStore,\n      colorLUTtoStore,\n      changeIsUserDownloadingSetting,\n      changeChartSessionSetting,\n      changeIsUserLoadSessionSetting,\n      changeSelectedNode,\n      isShowingLoadingModalToStore,\n      changeIsUserRelayoutSetting,\n    },\n    dispatch\n  );\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(GraphContainer);\n/*\nlabel: function (d) {\n                  let nodeData = d.data(\"data\");\n                  if (nodeData && nodeData.size) {\n                    let textLabel = nodeData.contents.join(\"\\n\");\n                    return textLabel;\n                  } else {\n                    return d.data(\"id\");\n                  }\n                },\n*/\n","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/navigation/navigation.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/navigationActions.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_graphsnp/comp_sider.js",["325"],"import React from \"react\";\nimport {\n  Button,\n  Row,\n  Col,\n  Select,\n  InputNumber,\n  Checkbox,\n  Divider,\n  Tooltip,\n  Modal,\n  Spin,\n  Slider,\n} from \"antd\";\nimport {\n  QuestionCircleOutlined,\n  LoadingOutlined,\n  ReloadOutlined,\n} from \"@ant-design/icons\";\nimport { connect } from \"react-redux\";\nimport * as constant from \"../utils/constants\";\nimport { bindActionCreators } from \"redux\";\nimport {\n  createClusterCSVFile,\n  createDOTGraph,\n} from \"../utils/create_exportFile\";\nimport {\n  selectDemoDataToStore,\n  sequenceToStore,\n  projectJSONToStore,\n  metadataToStore,\n  patientMovementToStore,\n  isinputLoadingToStore,\n} from \"../action/inputActions\";\nimport { hmmMatrixToStore } from \"../action/graphMatrixActions\";\nimport { colorLUTtoStore } from \"../action/colorActions\";\nimport { categoricalMapToStore } from \"../action/categoricalMapActions\";\nimport {\n  loadProjectJSON,\n  snpsLoader,\n  getMetadataInput,\n  getMatrixInput,\n  loadSNPsequence,\n} from \"../page_home/util_home\";\n\nimport {\n  changeMethodSetting,\n  changeLayoutSetting,\n  changeIsUserReDrawSetting,\n  changeEdgeFilterCutoffSetting,\n  changeClusterMethodSetting,\n  changeIsUserClusteringSetting,\n  changeExportFormatSetting,\n  changeIsUserDownloadingSetting,\n  changeColorNodeSetting,\n  changeIsEdgeScaledSetting,\n  changeEdgeScaleFactorSetting,\n  changeIsHideEdgesByCutoff,\n  changeEdgesHideCutoff,\n  changeTransIcludeLocLevel,\n  changeTypeOfAnalysisSetting,\n  changeIsUserFilterEdgesSetting,\n  changeIsUserRelayoutSetting,\n  changeSelectedNode,\n  changeNodeIsLabelShown,\n  changeEdgeLabelSizeSetting,\n} from \"../action/graphSettingsActions\";\nimport isShowingLoadingModalToStore from \"../action/isShowingLoadingModalActions\";\n\nconst { Option } = Select;\nconst loadingIcon = <LoadingOutlined style={{ fontSize: 34 }} spin />;\n\nconst SiderMenu = (props) => {\n  //GLOBAL VAR\n  //STATES\n\n  //SETTINGS\n  const graph_method = props.graphSettings.method;\n  const graph_layout = props.graphSettings.layout;\n  const graph_isUserReDraw = props.graphSettings.isUserReDraw;\n  const graph_isUserFilterEdges = props.graphSettings.isUserFilteringEdge;\n  const graph_edgeFilterCutoff = props.graphSettings.edgeFilterCutoff;\n  const graph_clusterMethod = props.graphSettings.clusterMethod;\n  const graph_isUserClustering = props.graphSettings.isUserClustering;\n  const graph_isEdgeScaled = props.graphSettings.isEdgeScaled;\n  const graph_edgeScaleFactor = props.graphSettings.edgeScaleFactor;\n  const graph_isEdgesHideByCutoff = props.graphSettings.isHideEdgesByCutoff;\n  const graph_edgesHideCutoff = props.graphSettings.hiddenEdgesCutoff;\n  const graph_colorNodeBy = props.graphSettings.colorNodedBy;\n  const graph_exportFormat = props.graphSettings.exportFormat;\n  const trans_locLevel = props.graphSettings.transIncludeLocLevel;\n  const graph_typeOfAnalysis = props.graphSettings.typeOfAnalysis;\n  const graph_isUserRelayout = props.graphSettings.isUserRelayout;\n  const graph_node_isLabelShown = props.graphSettings.node_isLabelShown;\n  const graph_edge_labelSize = props.graphSettings.edge_labelSize;\n  const selectedDemoData = props.selectDemoData;\n  let graph_nodeID_options = [];\n  let project_options = [];\n\n  //get nodeIDs from hamming matrix\n  if (props.hammMatrix) {\n    props.hammMatrix.forEach((v, k) => {\n      graph_nodeID_options.push(<Option key={k}>{k}</Option>);\n    });\n  }\n\n  //get preloaded project dataset for options\n  //List projects and create as options\n  if (props.projectJSON === null) {\n    loadProjectJSON(constant.PROJECTS_JSON_URL, props.projectJSONToStore);\n  }\n  if (props.projectJSON) {\n    props.projectJSON.forEach((v, k) => {\n      project_options.push(\n        <Option key={k} value={k}>\n          {v.name}\n        </Option>\n      );\n    });\n  }\n\n  //HANDLERS\n  const changeTypeOfAnalysisHandler = (val) => {\n    if (val === \"clustering\") {\n      props.changeMethodSetting(\"cathai\");\n    } else {\n      props.changeMethodSetting(\"seqtrack\");\n    }\n    props.changeTypeOfAnalysisSetting(val);\n  };\n\n  const changeMethodHandler = (val) => {\n    if (val === \"mscg\") {\n      props.changeLayoutSetting(\"cose-bilkent\");\n    } else {\n      props.changeLayoutSetting(\"cose\");\n    }\n    props.changeMethodSetting(val);\n  };\n\n  const changeLayoutHandler = (val) => {\n    if (graph_method === \"mscg\") {\n      props.changeLayoutSetting(\"cose-bilkent\");\n    }\n    props.changeLayoutSetting(val);\n  };\n\n  const reloadLayoutHandler = () => {\n    if (!graph_isUserRelayout) {\n      props.isShowingLoadingModalToStore(true);\n      props.changeIsUserRelayoutSetting(true);\n    }\n  };\n\n  const drawingHandler = () => {\n    if (!graph_isUserReDraw) {\n      props.isShowingLoadingModalToStore(true);\n      props.changeIsUserReDrawSetting(true);\n    }\n  };\n\n  const isUserFilterEdgesdHandler = (e) => {\n    let isChecked = e.target.checked;\n    props.changeIsUserFilterEdgesSetting(isChecked);\n  };\n\n  const edgeCutoffHandler = (val) => {\n    if (val > 0) {\n      props.changeEdgeFilterCutoffSetting(val);\n    }\n  };\n\n  const changeClusterMethodHandler = (val) => {\n    props.changeClusterMethodSetting(val);\n  };\n\n  const clusteringHandler = () => {\n    if (!graph_isUserClustering) {\n      props.changeIsUserClusteringSetting(true);\n    }\n  };\n\n  const changeColorNodeHandler = (val) => {\n    props.changeColorNodeSetting(val);\n  };\n\n  const changeExportFormatHandler = (val) => {\n    props.changeExportFormatSetting(val);\n  };\n\n  const isEdgeScaledHandler = (e) => {\n    let isChecked = e.target.checked;\n    props.changeIsEdgeScaledSetting(isChecked);\n  };\n\n  const edgeScaleFactorHandler = (val) => {\n    if (val > 0) {\n      props.changeEdgeScaleFactorSetting(val);\n    }\n  };\n\n  const isEdgeHideByCutoffHandler = (e) => {\n    let isChecked = e.target.checked;\n    props.changeIsHideEdgesByCutoff(isChecked);\n  };\n\n  const edgesHideCutoffMinHandler = (val) => {\n    if (val >= 0) {\n      let newEdgeCutoff = { min: val, max: graph_edgesHideCutoff.max };\n      props.changeEdgesHideCutoff(newEdgeCutoff);\n    }\n  };\n\n  const edgesHideCutoffMaxHandler = (val) => {\n    if (val > 0) {\n      let newEdgeCutoff = { min: graph_edgesHideCutoff.min, max: val };\n      props.changeEdgesHideCutoff(newEdgeCutoff);\n    }\n  };\n\n  const changeTransLocLevelHandler = (val) => {\n    props.changeTransIcludeLocLevel(val);\n  };\n\n  const selectNodeIDsHandler = (val) => {\n    props.changeSelectedNode(val);\n  };\n  const edge_labelSizeHandler = (val) => {\n    props.changeEdgeLabelSizeSetting(val);\n  };\n\n  const isNodeLabelShownHandler = (e) => {\n    let isChecked = e.target.checked;\n    props.changeNodeIsLabelShown(isChecked);\n  };\n\n  const exportingHandler = () => {\n    switch (graph_exportFormat) {\n      case \"clusterID\":\n        if (props.graphClusters) {\n          createClusterCSVFile(props.graphClusters.members);\n        } else {\n          alert(\"No file: Need to initiate detect cluster first \");\n        }\n        break;\n      case \"svg\":\n        props.changeIsUserDownloadingSetting(true);\n        break;\n      case \"dot\":\n        createDOTGraph(props.graphObject);\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  const selectDemoDataHandler = (val) => {\n    // case for each demo data\n    if (props.projectJSON && val) {\n      //clean all states\n      props.sequenceToStore(null);\n      props.hmmMatrixToStore(null);\n      props.metadataToStore(null);\n      props.colorLUTtoStore(null);\n      props.categoricalMapToStore(null);\n      props.patientMovementToStore(null);\n\n      //load a new one\n      let projectData = props.projectJSON.get(val);\n\n      //meta\n      if (projectData.metadata) {\n        getMetadataInput(\n          projectData.metadata,\n          props.metadataToStore,\n          props.colorLUTtoStore,\n          props.categoricalMapToStore,\n          props.isinputLoadingToStore\n        );\n      }\n\n      //if snps alignment\n      if (projectData.matrixOrAlignment === \"alignment\") {\n        if (projectData.snpDistance) {\n          loadSNPsequence(\n            //need to do this because different parsing with drag and drop one\n            projectData.snpDistance,\n            props.sequenceToStore,\n            props.hmmMatrixToStore,\n            props.isinputLoadingToStore,\n            snpsLoader\n          );\n        }\n      } else if (projectData.matrixOrAlignment === \"matrix\") {\n        if (projectData.snpDistance) {\n          getMatrixInput(\n            projectData.snpDistance,\n            props.hmmMatrixToStore,\n            props.isinputLoadingToStore\n          );\n        }\n      }\n\n      props.selectDemoDataToStore(val);\n    } else {\n      props.selectDemoDataToStore(null);\n    }\n  };\n\n  //input list data\n\n  const getColorOption = function (header, i) {\n    return (\n      <Option key={i} disabled={false} value={header}>\n        {header}\n      </Option>\n    );\n  };\n\n  return (\n    <React.Fragment>\n      <Row gutter={[8, 8]}>\n        <Col xs={24} id=\"modal-content\">\n          <Modal\n            visible={props.isShowingLoadingModal}\n            closable={false}\n            centered={true}\n            width={0}\n            footer={null}\n            bodyStyle={{\n              textAlign: \"center\",\n              padding: \"0px\",\n            }}\n          >\n            <Spin\n              indicator={loadingIcon}\n              style={{ color: \"white\" }}\n              tip=\"Preparing Graph\"\n              size=\"large\"\n            />\n          </Modal>\n        </Col>\n        <Col span={24}>\n          <h5>Preloaded dataset</h5>\n          <Select\n            value={selectedDemoData}\n            style={{ width: \"100%\", textOverflow: \"ellipsis\" }}\n            onChange={selectDemoDataHandler}\n          >\n            <Option value={null}>Select dataset</Option>\n            {project_options}\n          </Select>\n        </Col>\n\n        <Col span={24}>\n          <h5>Graph settings</h5>\n          <p>\n            Type of analysis{\" \"}\n            <span>\n              <Tooltip\n                title=\"Analysis to be performed. [1]Clustering: construct an undirected graph and detect putative cluster(s). [2]Transmission: construct a directed graph to show the putative transmission flow\"\n                placement=\"rightTop\"\n              >\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </p>\n          <Select\n            disabled={props.hammMatrix ? false : true}\n            value={graph_typeOfAnalysis}\n            style={{ width: \"100%\" }}\n            onChange={changeTypeOfAnalysisHandler}\n          >\n            <Option\n              disabled={props.hammMatrix ? false : true}\n              value=\"clustering\"\n            >\n              {\" \"}\n              Clustering{\" \"}\n            </Option>\n            <Option\n              disabled={props.hammMatrix && props.metadata ? false : true}\n              value=\"transmission\"\n            >\n              Transmission\n            </Option>\n          </Select>\n        </Col>\n\n        {graph_typeOfAnalysis === \"clustering\" && (\n          <Col span={24}>\n            <p>\n              Method{\" \"}\n              <span>\n                <Tooltip\n                  title=\"Method to construct clustering graph. \n                  [1] CATHAI: given the SNP cut-off, create networks of pairwise SNP-distances between samples (Forde et al. 2021)\"\n                  placement=\"rightTop\"\n                >\n                  <QuestionCircleOutlined style={{ color: \"red\" }} />\n                </Tooltip>\n              </span>\n            </p>\n            <Select\n              disabled={props.hammMatrix && graph_typeOfAnalysis ? false : true}\n              value={graph_method}\n              style={{ width: \"100%\" }}\n              onChange={changeMethodHandler}\n            >\n              <Option value=\"cathai\">CATHAI</Option>\n              <Option\n                value=\"mscg\"\n                disabled={graph_isUserFilterEdges ? false : true}\n              >\n                MST Single-linkage Cluster\n              </Option>\n            </Select>\n          </Col>\n        )}\n\n        {graph_typeOfAnalysis === \"transmission\" && (\n          <Col span={24}>\n            <p>\n              Method{\" \"}\n              <span>\n                <Tooltip\n                  title=\"Method to construct transmission graph. \n                  [1]SeqTrack: construct a parsimonous transmission tree based on SNP distances and sampling dates (Jombart et al. 2014). \n                  [2]SNPs and patient stay: construct a directed graph where edges were weighted by sum of SNPs distance weight and patient stays\"\n                  placement=\"rightTop\"\n                >\n                  <QuestionCircleOutlined style={{ color: \"red\" }} />\n                </Tooltip>\n              </span>\n            </p>\n            <Select\n              disabled={graph_typeOfAnalysis ? false : true}\n              value={graph_method}\n              style={{ width: \"100%\" }}\n              onChange={changeMethodHandler}\n            >\n              <Option\n                disabled={props.hammMatrix && props.metadata ? false : true}\n                value=\"seqtrack\"\n              >\n                SeqTrack\n              </Option>\n            </Select>\n          </Col>\n        )}\n\n        <Col span={16}>\n          <p>\n            Layout{\" \"}\n            <span>\n              <Tooltip\n                title=\"Layout to display the graph.\"\n                placement=\"rightTop\"\n              >\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </p>\n          <Select\n            disabled={props.hammMatrix ? false : true}\n            value={graph_layout}\n            style={{ width: \"100%\" }}\n            onChange={changeLayoutHandler}\n          >\n            <Option value=\"cose\"> CoSE</Option>\n            <Option value=\"spread\">Spread</Option>\n            <Option value=\"fcose\">fCoSE</Option>\n            <Option value=\"cose-bilkent\">CoSE Bilkent (Compound)</Option>\n            <Option value=\"dagre\">Dagre</Option>\n          </Select>\n        </Col>\n        <Col span={8}>\n          <p>\n            Refresh{\" \"}\n            <span>\n              <Tooltip\n                title=\"Apply selected layout to current graph.\"\n                placement=\"rightTop\"\n              >\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </p>\n          <Button\n            disabled={props.graphObject ? false : true}\n            onClick={reloadLayoutHandler}\n            type=\"primary\"\n          >\n            <ReloadOutlined />\n          </Button>\n        </Col>\n\n        <Col span={24}>\n          <Checkbox\n            style={{ fontSize: \"10px\" }}\n            onChange={isUserFilterEdgesdHandler}\n            checked={graph_isUserFilterEdges}\n            disabled={\n              props.hammMatrix && graph_typeOfAnalysis === \"clustering\"\n                ? false\n                : true\n            }\n          >\n            Apply SNPs cutoff{\" \"}\n            <span>\n              <Tooltip\n                title=\"Apply a cutoff number to limit the maximum pairwise SNPs distance to be displayed.\"\n                placement=\"rightTop\"\n              >\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </Checkbox>\n        </Col>\n\n        <Col span={24}>\n          <p>\n            Cutoff number{\" \"}\n            <span>\n              <Tooltip\n                title=\"Maximum pairwise SNPs distance to be included in graph \n                  (e.g. 25 SNPs cutoff will include edges with 0 to 25 SNPs).\"\n                placement=\"rightTop\"\n              >\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </p>\n          <InputNumber\n            min={0}\n            disabled={\n              graph_isUserFilterEdges &&\n              props.hammMatrix &&\n              graph_typeOfAnalysis === \"clustering\"\n                ? false\n                : true\n            }\n            step={1}\n            value={graph_edgeFilterCutoff}\n            onChange={edgeCutoffHandler}\n            style={{ marginBottom: \"5px\" }}\n          />\n        </Col>\n\n        {graph_method === \"hierSnpsMetaStayOverlap\" && (\n          <Col span={24}>\n            <p>\n              Filter weighted edges\n              <span>\n                <Tooltip\n                  title=\"Filter edges based on its weight. \n                The weight is a combination score computed from pairwise SNP distances and stay overlap in hierarhical order.\n                The weight assignation are: \n                #1 (all SNP distances), \n                #2 (#1+SNP distances less and equal to cutoff),\n                #3 (#2+They had overlap stay at hospital level),\n                #4 (#3+They had overlap stay at ward level),\n                #5 (#4+They had overlap stay at bay level), and\n                #6 (#5+They had overlap stay at bed level).\n                So an edge with weight of #6 represents the highest score for a possible transmission\n                based on their SNPs distance and stay overlap in bed level.\n                *Stay overlap is considered in 7 days range (REF)\"\n                  placement=\"rightTop\"\n                >\n                  <QuestionCircleOutlined style={{ color: \"red\" }} />\n                </Tooltip>\n              </span>\n            </p>\n            <Select\n              disabled={\n                graph_method === \"hierSnpsMetaStayOverlap\" ? false : true\n              }\n              value={trans_locLevel}\n              style={{ width: \"100%\" }}\n              onChange={changeTransLocLevelHandler}\n            >\n              <Option value={1}>SNPs</Option>\n              <Option value={2}>Hospital</Option>\n              <Option value={3}>Ward</Option>\n              <Option value={4}>Bay</Option>\n              <Option value={5}>Bed</Option>\n            </Select>\n          </Col>\n        )}\n\n        <Col span={24}>\n          <Button\n            disabled={props.hammMatrix ? false : true}\n            onClick={drawingHandler}\n            type=\"primary\"\n          >\n            Create graph\n          </Button>\n        </Col>\n\n        {graph_typeOfAnalysis === \"clustering\" && props.graphObject && (\n          <Divider style={{ margin: \"10px 0px 0px 0px\" }} />\n        )}\n\n        {graph_typeOfAnalysis === \"clustering\" && props.graphObject && (\n          <Col span={24}>\n            <h5>Clustering settings</h5>\n            <p>\n              Method{\" \"}\n              <span>\n                <Tooltip\n                  title=\"Method to detect cluster in the constructed graph.\n                  [1]Connected components: using Breadth-first search algorithm (Zhou and Hansen,2006) to find cluster (all connected nodes)\n                  [2]Louvain: using Louvain algoritm (Subelj and Bajec, 2011) to find the cluster(s) \"\n                  placement=\"rightTop\"\n                >\n                  <QuestionCircleOutlined style={{ color: \"red\" }} />\n                </Tooltip>\n              </span>\n            </p>\n            <Select\n              disabled={props.graphObject ? false : true}\n              value={graph_clusterMethod}\n              style={{ width: \"100%\" }}\n              onChange={changeClusterMethodHandler}\n            >\n              <Option value=\"Connected Components\">Connected Components</Option>\n            </Select>\n          </Col>\n        )}\n\n        {graph_typeOfAnalysis === \"clustering\" && props.graphObject && (\n          <Col span={24}>\n            <Button\n              type=\"primary\"\n              disabled={props.graphObject ? false : true}\n              onClick={clusteringHandler}\n            >\n              Detect clusters\n            </Button>\n          </Col>\n        )}\n\n        <Divider style={{ margin: \"10px 0px 0px 0px\" }} />\n\n        <h5>Node settings</h5>\n        <Col span={24}>\n          <p>\n            Node color{\" \"}\n            <span>\n              <Tooltip\n                title=\"Color nodes by the selected column in metadata or by the clustering result.\n                User can also specify the color manually\n                (e.g. To specify color on column 'patient_group', add new column named 'patient_group:color' in metadata).\"\n                placement=\"rightTop\"\n              >\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </p>\n          <Select\n            disabled={props.graphObject ? false : true}\n            value={graph_colorNodeBy}\n            style={{ width: \"100%\" }}\n            onChange={changeColorNodeHandler}\n          >\n            {\" \"}\n            {props.colorLUT && Object.keys(props.colorLUT)\n              ? Object.keys(props.colorLUT).map((k, i) => {\n                  return getColorOption(k, i);\n                })\n              : [\"na\"].map((l, j) => {\n                  return getColorOption(l, j);\n                })}\n          </Select>\n        </Col>\n        <Col span={24}>\n          <p>\n            Select node(s){\" \"}\n            <span>\n              <Tooltip\n                title=\"Select one or more node IDs to highlight the node(s) on the graph\"\n                placement=\"rightTop\"\n              >\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </p>\n          <Select\n            mode=\"multiple\"\n            allowClear\n            style={{ width: \"100%\" }}\n            placeholder=\"Select ID(s)\"\n            onChange={selectNodeIDsHandler}\n            value={props.selectedNode}\n          >\n            {graph_nodeID_options}\n          </Select>\n        </Col>\n\n        <Col span={24}>\n          <Checkbox\n            style={{ fontSize: \"10px\" }}\n            onChange={isNodeLabelShownHandler}\n            checked={graph_node_isLabelShown}\n            disabled={props.graphObject ? false : true}\n          >\n            Show node label{\" \"}\n            <span>\n              <Tooltip title=\"Show or hide node's label.\" placement=\"rightTop\">\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </Checkbox>\n        </Col>\n\n        <h5>Edge settings</h5>\n        <Col span={24}>\n          <p>\n            Edge label size{\" \"}\n            <span>\n              <Tooltip title=\"Change edge label size\" placement=\"rightTop\">\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </p>\n          <Slider\n            value={props.graphSettings.edge_labelSize}\n            min={0}\n            max={100}\n            onChange={edge_labelSizeHandler}\n            disabled={props.graphObject ? false : true}\n          />\n        </Col>\n\n        <Col span={24}>\n          <Checkbox\n            style={{ fontSize: \"10px\" }}\n            onChange={isEdgeScaledHandler}\n            checked={graph_isEdgeScaled}\n            disabled={props.graphObject ? false : true}\n          >\n            Scale edge to weight{\" \"}\n            <span>\n              <Tooltip\n                title=\"Change the thickness of the edge accordin to its weight.\n                  (e.g. the higher the transmission score the thicker the line).\"\n                placement=\"rightTop\"\n              >\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </Checkbox>\n        </Col>\n        <Col span={24}>\n          <p>\n            Scaling factor{\" \"}\n            <span>\n              <Tooltip\n                title=\"Multiply the thickness of the edge with the scaling factor (positive number greater than zero)\"\n                placement=\"rightTop\"\n              >\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </p>\n          <InputNumber\n            min={0.00001}\n            disabled={graph_isEdgeScaled && props.graphObject ? false : true}\n            step={0.1}\n            value={graph_edgeScaleFactor}\n            onChange={edgeScaleFactorHandler}\n          />\n        </Col>\n\n        <Col span={24}>\n          <Checkbox\n            style={{ fontSize: \"10px\" }}\n            onChange={isEdgeHideByCutoffHandler}\n            checked={graph_isEdgesHideByCutoff}\n            disabled={props.graphObject ? false : true}\n          >\n            Show partial edges{\" \"}\n            <span>\n              <Tooltip\n                title=\"Only show edges which have weight within the specified range (min to max)\n                (Note: It doesn't remove the edges but only hide it to the background)\"\n                placement=\"rightTop\"\n              >\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </Checkbox>\n        </Col>\n\n        <Col span={11}>\n          <p>Minimum</p>\n          <InputNumber\n            min={0}\n            disabled={\n              graph_isEdgesHideByCutoff && props.graphObject ? false : true\n            }\n            step={0.1}\n            value={graph_edgesHideCutoff.min}\n            onChange={edgesHideCutoffMinHandler}\n          />\n        </Col>\n\n        <Col span={11}>\n          <p>Maximum</p>\n          <InputNumber\n            min={0}\n            disabled={\n              graph_isEdgesHideByCutoff && props.graphObject ? false : true\n            }\n            step={0.1}\n            value={graph_edgesHideCutoff.max}\n            onChange={edgesHideCutoffMaxHandler}\n          />\n        </Col>\n\n        <Col span={24}>\n          <h5>Download settings</h5>\n          <p>\n            Type{\" \"}\n            <span>\n              <Tooltip\n                title=\"Type of file to be downloaded: \n                [1]Graph image (SVG)\n                [2]Graph object file (DOT format: suitable for visualization with HAIviz)\n                [3]Clustering result (CSV).\"\n                placement=\"rightTop\"\n              >\n                <QuestionCircleOutlined style={{ color: \"red\" }} />\n              </Tooltip>\n            </span>\n          </p>\n          <Select\n            value={graph_exportFormat}\n            style={{ width: \"100%\" }}\n            onChange={changeExportFormatHandler}\n            disabled={props.graphObject || props.graphClusters ? false : true}\n          >\n            <Option disabled={props.graphObject ? false : true} value=\"svg\">\n              Graph image (SVG)\n            </Option>\n            <Option disabled={props.graphObject ? false : true} value=\"dot\">\n              Graph file (DOT)\n            </Option>\n            <Option\n              disabled={props.graphClusters ? false : true}\n              value=\"clusterID\"\n            >\n              Clustering result (CSV)\n            </Option>\n          </Select>\n        </Col>\n        <Col span={24}>\n          <Button\n            disabled={props.graphClusters || props.graphObject ? false : true}\n            onClick={exportingHandler}\n            type=\"primary\"\n          >\n            Download\n          </Button>\n        </Col>\n      </Row>\n    </React.Fragment>\n  );\n};\n\nfunction mapStateToProps(state) {\n  return {\n    metadata: state.metadata,\n    patientMovement: state.patientMovement,\n    sequence: state.sequence,\n    hammMatrix: state.hammMatrix,\n    graphSettings: state.graphSettings,\n    graphObject: state.graphObject,\n    graphClusters: state.graphClusters,\n    colorLUT: state.colorLUT,\n    isShowingLoadingModal: state.isShowingLoadingModal,\n    selectedNode: state.selectedNode,\n    selectDemoData: state.selectDemoData,\n    projectJSON: state.projectJSON,\n  };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return bindActionCreators(\n    {\n      changeMethodSetting,\n      changeLayoutSetting,\n      changeIsUserReDrawSetting,\n      changeEdgeFilterCutoffSetting,\n      changeClusterMethodSetting,\n      changeIsUserClusteringSetting,\n      changeIsEdgeScaledSetting,\n      changeEdgeScaleFactorSetting,\n      changeColorNodeSetting,\n      changeExportFormatSetting,\n      changeIsUserDownloadingSetting,\n      changeIsHideEdgesByCutoff,\n      changeEdgesHideCutoff,\n      changeTransIcludeLocLevel,\n      changeTypeOfAnalysisSetting,\n      changeIsUserFilterEdgesSetting,\n      changeIsUserRelayoutSetting,\n      changeEdgeLabelSizeSetting,\n      changeNodeIsLabelShown,\n      isShowingLoadingModalToStore,\n      changeSelectedNode,\n      projectJSONToStore,\n      selectDemoDataToStore,\n      sequenceToStore,\n      metadataToStore,\n      patientMovementToStore,\n      isinputLoadingToStore,\n      hmmMatrixToStore,\n      colorLUTtoStore,\n      categoricalMapToStore,\n    },\n    dispatch\n  );\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(SiderMenu);\n\n/*\n<Option disabled={props.hammMatrix && props.metadata ? false : true} value=\"hierSnpsMetaStayOverlap\">\n                SNPs and patient stay\n              </Option>\n\n                            <Option\n                disabled={props.hammMatrix && props.metadata ? false : true}\n                value=\"cge\"\n              >\n                CATHAI + metadata\n              </Option>\n*/\n","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_snpDist_settings.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_home/comp_selectDemoData.js",["326"],"import React from \"react\";\nimport { Col, Select } from \"antd\";\nimport { connect } from \"react-redux\";\nimport * as constant from \"../utils/constants\";\nimport { hmmMatrixToStore } from \"../action/graphMatrixActions\";\n\nimport { bindActionCreators } from \"redux\";\nimport {\n  selectDemoDataToStore,\n  sequenceToStore,\n  projectJSONToStore,\n  metadataToStore,\n  patientMovementToStore,\n  isinputLoadingToStore,\n} from \"../action/inputActions\";\nimport { colorLUTtoStore } from \"../action/colorActions\";\nimport { categoricalMapToStore } from \"../action/categoricalMapActions\";\nimport {\n  loadProjectJSON,\n  snpsLoader,\n  getMetadataInput,\n  getMatrixInput,\n  loadSNPsequence,\n} from \"./util_home\";\n\nconst { Option } = Select;\n\nconst SelectDemoData = (props) => {\n  let project_options = [];\n\n  //RETRIEVE PROJECTS.JSON\n  if (props.projectJSON === null) {\n    loadProjectJSON(constant.PROJECTS_JSON_URL, props.projectJSONToStore);\n  }\n\n  //List projects and create as options\n  if (props.projectJSON) {\n    props.projectJSON.forEach((v, k) => {\n      project_options.push(\n        <Option key={k} value={k}>\n          {v.name}\n        </Option>\n      );\n    });\n  }\n\n  const selectedDemoData = props.selectDemoData;\n\n  const selectDemoDataHandler = (val) => {\n    if (props.projectJSON && val) {\n      props.sequenceToStore(null);\n      props.hmmMatrixToStore(null);\n      props.metadataToStore(null);\n      props.colorLUTtoStore(null);\n      props.categoricalMapToStore(null);\n      props.patientMovementToStore(null);\n\n      //load a new one\n      let projectData = props.projectJSON.get(val);\n\n      //meta\n      if (projectData.metadata) {\n        getMetadataInput(\n          projectData.metadata,\n          props.metadataToStore,\n          props.colorLUTtoStore,\n          props.categoricalMapToStore,\n          props.isinputLoadingToStore\n        );\n      }\n\n      //if snps alignment\n      if (projectData.matrixOrAlignment === \"alignment\") {\n        if (projectData.snpDistance) {\n          loadSNPsequence(\n            //need to do this because different parsing with drag and drop one\n            projectData.snpDistance,\n            props.sequenceToStore,\n            props.hmmMatrixToStore,\n            props.isinputLoadingToStore,\n            snpsLoader\n          );\n        }\n      } else if (projectData.matrixOrAlignment === \"matrix\") {\n        if (projectData.snpDistance) {\n          getMatrixInput(\n            projectData.snpDistance,\n            props.hmmMatrixToStore,\n            props.isinputLoadingToStore\n          );\n        }\n      }\n\n      props.selectDemoDataToStore(val);\n    } else {\n      props.selectDemoDataToStore(null);\n    }\n  };\n\n  return (\n    <React.Fragment>\n      <Select\n        value={selectedDemoData}\n        onChange={selectDemoDataHandler}\n        className={\"gp-select\"}>\n        <Option value={null}>Preloaded dataset</Option>\n        {project_options}\n      </Select>\n    </React.Fragment>\n  );\n};\n\nfunction mapStateToProps(state) {\n  return {\n    projectJSON: state.projectJSON,\n    selectDemoData: state.selectDemoData,\n  };\n}\nfunction mapDispatchToProps(dispatch) {\n  return bindActionCreators(\n    {\n      projectJSONToStore,\n      selectDemoDataToStore,\n      sequenceToStore,\n      metadataToStore,\n      patientMovementToStore,\n      isinputLoadingToStore,\n      hmmMatrixToStore,\n      colorLUTtoStore,\n      categoricalMapToStore,\n    },\n    dispatch\n  );\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(SelectDemoData);\n\n/*\n */\n","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_snpDist_viewer.js",["327","328","329","330"],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_home/comp_inputPlaceholder.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_home/comp_footer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/img/circle.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/projectsReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/sequenceReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/navSettingsReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/graphSettingsReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/metadataReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/patientMovementReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/isInputLoadingReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/graphObjectReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/hammMatrixReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/graphClustersReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/colorLUTReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/categoricalMapReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/selectDemoDataReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/snpDistSettingsReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/selectedNodeReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/reducers/isShowingLoadingModalReducer.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/constants.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/graphSettingsActions.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/colorActions.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/create_graphObject.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/create_cyData.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/create_exportFile.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/find_clusters.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/utils/utils.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/graphMatrixActions.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/isShowingLoadingModalActions.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/model/hammingMatrix_prop.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/categoricalMapActions.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/inputActions.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_home/util_home.js",["331"],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/action/snpdistSettingsActions.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/model/distanceMatrix_prop.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/construct_mscg.js",["332"],"//========================================== Minimum Spanning Cut-Off Graph ================================================\nimport GraphEdgeList from \"../model/graphEdgeList_prop\";\nimport { findConnectedComponents } from \"./cluster_fcc\";\nimport { min } from \"d3-array\";\nconst kruskalMST = require(\"kruskal-mst\");\nconst _ = require(\"lodash\");\nexport function createMSCG(rawMatrix, edgeCutoff) {\n  //Assumed the input is true\n  //Take an adjacency Map of pair-wise SNVs distance and edgecutoff (number > 0)\n  //Return graph with only edge that have minimum value among other pair-wise sibling edges (format adjacency list)\n  let mat = _.cloneDeep(rawMatrix);\n\n  let minDistLut = new Map();\n  let nodeList_CATHAI = [];\n  let edgeList_CATHAI = [];\n\n  mat.forEach((val, key) => {\n    //1. create LUT containing all key and their minimum dist ======\n\n    //2. perform CATHAI  ======\n    //+save nodes\n    nodeList_CATHAI.push(key);\n    //+remove edges below the cut-off\n    if (edgeCutoff !== null && edgeCutoff > 0) {\n      let filteredVal = val.filter((e) => {\n        return e.value <= edgeCutoff;\n      });\n      //+merge them\n      edgeList_CATHAI = edgeList_CATHAI.concat(filteredVal);\n    }\n  });\n\n  //remove inverse duplicates edges\n  let graphEdgeList = new GraphEdgeList(\n    nodeList_CATHAI,\n    edgeList_CATHAI\n  ).getSymetricEdges();\n  let graphObject_simplified = {\n    nodes: graphEdgeList.nodes,\n    edges: graphEdgeList.edges,\n  };\n\n  //3. perform FCC\n  let fcc_clusters = findConnectedComponents(graphObject_simplified);\n\n  //4. build the MSCG\n  let nodelist_MSCG = [];\n  let edgelist_MSCG = [];\n  let singletons = fcc_clusters.members.filter((d) => {\n    if (d.clusterID === \"na\") {\n      return true;\n    } else {\n      return false;\n    }\n  });\n\n  //+create relationship between identified clusters and other singleton\n  if (fcc_clusters.group.length > 0) {\n    for (let i = 0; i < fcc_clusters.group.length; i++) {\n      let sourceClusterID = \"Group \" + (i + 1);\n\n      let sourceClusterMembers = fcc_clusters.group[i];\n      nodelist_MSCG.push({\n        id: sourceClusterID,\n        data: {\n          type: \"compound\",\n          size: sourceClusterMembers.length,\n          contents: sourceClusterMembers,\n        },\n      });\n\n      //+get pairwise cluster to cluster\n      for (let j = i + 1; j < fcc_clusters.group.length; j++) {\n        let targetClusterID = \"Group \" + (j + 1);\n        if (sourceClusterID !== targetClusterID) {\n          let targetClusterMembers = fcc_clusters.group[j];\n          let minDist = [];\n          sourceClusterMembers.forEach((sc) => {\n            targetClusterMembers.forEach((tc) => {\n              let dist = mat\n                .get(sc)\n                .filter((d) => (d.target === tc ? true : false));\n              minDist.push(dist[0].value);\n            });\n          });\n          //create edgelist\n          edgelist_MSCG.push({\n            source: sourceClusterID,\n            target: targetClusterID,\n            value: min(minDist),\n          });\n        }\n      }\n\n      //+get pairwise cluster to singletons\n      for (let k = 0; k < singletons.length; k++) {\n        let targetSingleton = singletons[k].sample;\n        let minDistCS = [];\n        sourceClusterMembers.forEach((sc) => {\n          let dist = mat\n            .get(sc)\n            .filter((d) => (d.target === targetSingleton ? true : false));\n          minDistCS.push(dist[0].value);\n        });\n        //create edgelist\n        edgelist_MSCG.push({\n          source: sourceClusterID,\n          target: targetSingleton,\n          value: min(minDistCS),\n        });\n      }\n    }\n  }\n\n  //+create relationship between singleton to singleton\n  if (singletons.length > 0) {\n    for (let l = 0; l < singletons.length; l++) {\n      //add singleton as node\n      let sourceS = singletons[l].sample;\n      nodelist_MSCG.push({\n        id: sourceS,\n        data: {\n          type: \"singleton\",\n          size: null,\n          contents: null,\n        },\n      });\n\n      for (let m = l + 1; m < singletons.length; m++) {\n        let targetS = singletons[m].sample;\n        if (sourceS !== targetS) {\n          //create edgelist between singletons\n          let sourceS_LUT = mat.get(sourceS).filter((s) => {\n            if (s.target === targetS) {\n              return true;\n            } else {\n              return false;\n            }\n          });\n\n          edgelist_MSCG.push({\n            source: sourceS,\n            target: targetS,\n            value: sourceS_LUT[0].value,\n          });\n        }\n      }\n    }\n  }\n\n  //5. Perform MST\n  //+transform edges\n  let kruskalEdges = edgelist_MSCG.map((d) => {\n    return { from: d.source, to: d.target, weight: d.value };\n  });\n  let mstEdges = kruskalMST.kruskal(kruskalEdges);\n\n  //+transfom back\n  let finalEdges = mstEdges.map((d) => {\n    return { source: d.from, target: d.to, value: d.weight };\n  });\n\n  return {\n    nodes: nodelist_MSCG,\n    edges: finalEdges,\n    clusterGroup: fcc_clusters,\n  };\n}\n","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/construct_seqtrack.js",["333","334"],"//========================================== SeqTrack ================================================\n/* Adapted from SeqTrack algorithm implemented in:\n- paper\n*/\nimport GraphEdgeList from \"../model/graphEdgeList_prop\";\nimport Moment from \"moment\";\nimport { extendMoment } from \"moment-range\";\n\nconst _ = require(\"lodash\");\nconst moment = extendMoment(Moment);\nvar dbinom = require(\"@stdlib/stats-base-dists-binomial-pmf\");\n\nexport function createSeqTrack(\n  rawMatrix,\n  metadataMap,\n  snpSeq_len,\n  mut_rate = null\n) {\n  let hammingDistMat = _.cloneDeep(rawMatrix);\n  //make list of case id and metadata based on SNP alignment\n  //error check\n  let paramsError = false;\n  let cases = []; //list of case object [ {id: caseID, date: caseDate}, ...  ]\n  let missingMeta = [];\n\n  hammingDistMat.forEach((val, key) => {\n    let caseID = key;\n    let meta = metadataMap.get(key);\n    let colDay = meta && meta.collection_day ? meta.collection_day : null;\n    if (meta && colDay) {\n      cases.push({ id: caseID, day: colDay });\n    } else {\n      paramsError = true;\n      missingMeta.push(caseID);\n    }\n  });\n\n  //check that all id in alignment have metadata (we only collection_day)\n  if (paramsError) {\n    alert(\"No collection day data for id(s): \", missingMeta.join(\", \"));\n  }\n\n  //Fun 4: Running selAmongAncestors\n  function selAmongAncestors(\n    aCase,\n    ancesWithLowestSNPdist,\n    snpLen = snpSeq_len,\n    mu = mut_rate,\n    metadata = metadataMap\n  ) {\n    //if proximity matrix is available do here:\n    //but not now, because we dont have one in graphsnp\n\n    if (ancesWithLowestSNPdist.length > 1) {\n      let ancesWithLowestSNPdist_wDay = ancesWithLowestSNPdist\n        .map((d) => {\n          d[\"day\"] = metadata.get(d.id).collection_day;\n          return d;\n        })\n        .sort((a, b) => a.day > b.day);\n\n      // if mutation rate not available, choose the oldest one\n\n      if (!mut_rate || !snpLen) {\n        let oldestAnces = ancesWithLowestSNPdist_wDay[0];\n        return { ances: oldestAnces.id, snpDist: oldestAnces.snpDist };\n      } else {\n        console.log(\"with mutation\");\n        let case_day = aCase.day;\n        let ancesWithLowestSNPdist_wDayDiff = ancesWithLowestSNPdist_wDay.map(\n          (a) => {\n            let timeDiff = Math.abs(case_day - a.day);\n            let prob = dbinom(a.snpDist, timeDiff * snpLen, mu);\n            a[\"dayDiff\"] = timeDiff;\n            a[\"probability\"] = prob;\n            return a;\n          }\n        );\n        let sorted_ancesWithLowestSNPdist_wDayDiff =\n          ancesWithLowestSNPdist_wDayDiff.sort(\n            (a, b) => a.probability < b.probability\n          );\n        let mostProbableAnces = sorted_ancesWithLowestSNPdist_wDayDiff[0];\n        // improvement: if there are two equaly most probable ances, return all.\n        return {\n          ances: mostProbableAnces.id,\n          snpDist: mostProbableAnces.snpDist,\n        };\n      }\n    }\n  }\n\n  //Fun 3: Get snp distances between case to its ances candidates, then select the lowest\n  function compareAncesSNPdist(aCase, ancesCanditates, hammingDistMat) {\n    let snpDistAnces = [];\n    for (let i = 0; i < ancesCanditates.length; i++) {\n      const ancesCandId = ancesCanditates[i].id;\n      // edgesOfAnces is a list of object paired (both dir)\n      let edgesOfAnces = hammingDistMat.get(ancesCandId).filter((d) => {\n        if (d.target === aCase.id) {\n          return true;\n        } else {\n          return false;\n        }\n      });\n\n      snpDistAnces.push({ id: ancesCandId, snpDist: edgesOfAnces[0].value });\n    }\n\n    snpDistAnces.sort((a, b) => a.snpDist - b.snpDist);\n    // console.log(\"snpDistAnces\", snpDistAnces);\n    //which ances has the lowest SNP dist?\n    let lowestSNPdistAnces = snpDistAnces.filter((e) => {\n      if (e.snpDist === snpDistAnces[0].snpDist) {\n        return true;\n      } else {\n        return false;\n      }\n    });\n    // console.log(\"lowestSNPdistAnces\", lowestSNPdistAnces);\n    return lowestSNPdistAnces;\n  }\n\n  //Fun 2: Running and calling selAmongAncestors\n  function findAncestor(aCase, cases, hammingDistMat) {\n    //Search and return 1 best ancestor for a caseID, from the list of available cases\n    //+based on case's collection day, and (if available) mutation rate and haplo length\n    //+(length of snp sites)\n    let bestAncestor = { ances: null, snpDist: null };\n    //1. Find ancestor candidates: other case(s) which collected before this caseId\n    let candid = cases.filter((c) => {\n      if (c.day < aCase.day) {\n        return true;\n      } else {\n        return false;\n      }\n    });\n    //2. Check whether this case have ancestor(s) or not. If no its the index case (ancestor = 'NA')\n    //+ if has multiple canditates, run selAmongAncestors to choose 1 most likely candidate\n\n    // if it is index case, set ances to NA, return bestAnces\n    if (candid.length === 0) {\n      bestAncestor.ances = \"NA\";\n      bestAncestor.snpDist = \"NA\";\n      // console.log(\"index case:\", bestAncestor);\n      return bestAncestor; // fun stop here\n    }\n\n    // if it is the second case (only have 1 candidate). set ances to identified ances, return bestAnces\n    else if (candid.length === 1) {\n      bestAncestor.ances = candid[0].id;\n      let candidHamDist = hammingDistMat.get(candid[0].id).filter((d) => {\n        let cond = d.target === aCase.id ? true : false;\n        return cond;\n      });\n      bestAncestor.snpDist = candidHamDist[0].value;\n      // console.log(\"second case:\", bestAncestor);\n      return bestAncestor; // fun stop here\n    }\n\n    // for any other cases (multiple candidates were found)\n    else {\n      //filter candidates based on their snp distance, get candidate(s) with the least snpDist\n      let ancesWithLowestSNPdist = compareAncesSNPdist(\n        aCase,\n        candid,\n        hammingDistMat\n      ); //return a list of ances(s) [{}, {}]\n\n      //check if ancesWithLowestSNPdist is more than 1\n      if (ancesWithLowestSNPdist.length > 1) {\n        let selectedAnces = selAmongAncestors(aCase, ancesWithLowestSNPdist);\n        bestAncestor.ances = selectedAnces.ances;\n        bestAncestor.snpDist = selectedAnces.snpDist;\n        return bestAncestor;\n      } else {\n        //ancesWithLowestSNPdist is a list of one object [{ances: 'ancesID', snpDist: number}]\n        bestAncestor.ances = ancesWithLowestSNPdist[0].id;\n        bestAncestor.snpDist = ancesWithLowestSNPdist[0].snpDist;\n        return bestAncestor;\n      }\n    }\n  }\n\n  // PERFORM THIS FUN IF ALL REQUIREMENTS ARE MET\n  if (!paramsError) {\n    //initial result\n    let res = new Map();\n    for (let index = 0; index < cases.length; index++) {\n      const thisCase = cases[index];\n      // thisCase = aCase = {id: xxx, day: yyy}\n      //Fun 1: calling findAncestor function\n      let ancestor = findAncestor(thisCase, cases, hammingDistMat); //must return one best ancestor object for this caseId {ances: sample_id, snpDist= null}\n      //set the ancestor of this case to the result map\n      res.set(thisCase.id, ancestor);\n    }\n\n    //create a final graph object from the res map object\n    let final_graph = { nodes: [], edges: [] };\n    res.forEach((v, k) => {\n      final_graph.nodes.push(k);\n      if (v.ances !== \"NA\") {\n        final_graph.edges.push({\n          source: v.ances,\n          target: k,\n          value: v.snpDist,\n          dir: \"forward\",\n        });\n      }\n    });\n    //final_graph.nodes.push(\"NA\");\n\n    //return final graph\n\n    return final_graph;\n  } else {\n    let final_graph = { nodes: null, edges: null };\n    return final_graph;\n  }\n}\n","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/cluster_louvain.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/cluster_fcc.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/model/graphEdgeList_prop.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/construct_smso.js",["335","336"],"//========================================== SMSO ================================================\n/*\nCreate a directed graph object that edges represent transmissions\nDirected edges was created only if pair-wise of isolates has transmission signal\nTransmission signal were if transmission score >= 1, created by check patient stay overlap hiearchiely\n\n*/\n\nimport GraphEdgeList from \"../model/graphEdgeList_prop\";\nimport Moment from \"moment\";\nimport { extendMoment } from \"moment-range\";\nimport StayList from \"../model/stayList_prop\";\nimport {\n  getHighestLocation,\n  filterInverseSymEdges,\n  getOverlapLocationLevel,\n} from \"../utils/utils\";\n\nconst moment = extendMoment(Moment);\nconst _ = require(\"lodash\");\n\nexport function createSMSO(\n  rawMatrix,\n  edgeCutoff,\n  rawPatientMovementData,\n  metadata,\n  trans_locLevel\n) {\n  //Assumed the input is true\n  //Take an adjacency matrix of pair-wise SNVs distance and edgecutoff (number > 0)\n  //Return graph with only edge <= cut-off\n  let mat = _.cloneDeep(rawMatrix);\n  let patientMovementData = _.cloneDeep(rawPatientMovementData);\n  let edgeList = [];\n  let nodeList = [];\n  mat.forEach((val, key) => {\n    nodeList.push(key);\n    let sortedRow = val;\n\n    //Filter by cut-off\n    if (edgeCutoff !== null && edgeCutoff > 0) {\n      sortedRow = sortedRow.filter((e) => {\n        return e.value <= edgeCutoff;\n      });\n    }\n\n    //merge\n    edgeList = edgeList.concat(sortedRow);\n  });\n\n  //Asses transmission signal on each edge\n  let directedEdges = [];\n  let undirectedEdges = [];\n  if (edgeList.length > 0) {\n    for (let i = 0; i < edgeList.length; i++) {\n      let e = edgeList[i];\n      //get pid\n      let p1_id = metadata.get(e.source).patient_id;\n      let p2_id = metadata.get(e.target).patient_id;\n\n      let p1_sampleDate = moment(metadata.get(e.source).sample_date);\n      let p2_sampleDate = moment(metadata.get(e.target).sample_date);\n\n      //get the stays\n      let p1_stays = patientMovementData.get(p1_id)\n        ? new StayList(patientMovementData.get(p1_id))\n        : null;\n\n      let p2_stays = patientMovementData.get(p2_id)\n        ? new StayList(patientMovementData.get(p2_id))\n        : null;\n\n      //console.log(p1_id, p1_stays_obj instanceof StayList);\n      //console.log(p1_id, p1_stays_obj);\n\n      //if we have stays data for both isolates, do, else return 0 and break\n      //console.log(p1_id, p1_stays);\n      if (\n        p1_stays instanceof StayList &&\n        p2_stays instanceof StayList &&\n        Array.isArray(p1_stays.stays) &&\n        Array.isArray(p2_stays.stays) &&\n        p1_stays.stays.length > 0 &&\n        p2_stays.stays.length > 0\n      ) {\n        //which location level do these patients shared? hospital=1? ward=2? bay=3? bed=4?\n        //console.log(p1_stays_obj);\n        //console.log(p1_stays_obj.getLocationLevel());\n        let p1_locLevel = p1_stays.getLocationLevel();\n        let p2_locLevel = p2_stays.getLocationLevel();\n        let common_locLevel = Math.min(p1_locLevel, p2_locLevel)\n          ? Math.min(p1_locLevel, p2_locLevel)\n          : null;\n\n        //console.log(common_locLevel, p1_locLevel, p2_locLevel);\n\n        //if they dont shared any location, not even hospital, return e as undirected with score = 1 (genomic only)\n        if (!common_locLevel) {\n          e[\"dir\"] = \"none\";\n          e.value = 1;\n          undirectedEdges.push(e);\n        } else {\n          //if they share location, at least hospital\n          //check whether that had any overlap admission\n          let p1_rangeOfStay = p1_stays.getRangeOfStays();\n          let p2_rangeOfStay = p2_stays.getRangeOfStays();\n\n          let p1_range = moment.range(\n            p1_rangeOfStay.start_date.startOf(\"day\"),\n            p1_rangeOfStay.end_date.endOf(\"day\")\n          );\n          let p2_range = moment.range(\n            p2_rangeOfStay.start_date.startOf(\"day\"),\n            p2_rangeOfStay.end_date.endOf(\"day\")\n          );\n          let is_p1_p2_overlap = p1_range.overlaps(p2_range);\n          if (is_p1_p2_overlap) {\n            //they do have overlap\n            //compare the highest common level of location (common_locLevel) for both patients\n\n            if (p2_sampleDate.isAfter(p1_sampleDate, \"day\")) {\n              let transmissionScore = calculateTransScore(\n                p1_id,\n                p2_id,\n                p1_stays,\n                p2_stays,\n                common_locLevel\n              );\n              e[\"dir\"] = \"forward\";\n              e.value = 1 + transmissionScore;\n              directedEdges.push(e);\n            } else {\n              e[\"dir\"] = \"none\";\n              e.value = 1;\n              undirectedEdges.push(e);\n            }\n          } else {\n            //they dont have any overlap\n            e[\"dir\"] = \"none\";\n            e.value = 1;\n            undirectedEdges.push(e);\n          }\n        }\n      } else {\n        e[\"dir\"] = \"none\";\n        e.value = 1;\n        undirectedEdges.push(e);\n      }\n    }\n  }\n\n  //let clean_undirectedEdges = filterInverseSymEdges(undirectedEdges);\n  //merge edges\n\n  directedEdges = directedEdges.filter((e) => {\n    return e.value >= trans_locLevel;\n  });\n\n  //SCORING: 1: snps only, 2: snps+hospital, 3: snps+ ward, 4: snps+bay, 5: snps+bed\n\n  //return nodes and edges with direction property\n  //[edgeList[0]]\n\n  return { nodes: nodeList, edges: directedEdges };\n}\n\nfunction calculateTransScore(p1, p2, p1_stays, p2_stays, common_locLevel) {\n  let scoreOverlap = 0;\n\n  //filter stays to only to the level of both patients shared location\n  let p1_stays_common = p1_stays.stays.filter((s) => {\n    return getHighestLocation(s) === common_locLevel;\n  });\n  let p2_stays_common = p2_stays.stays.filter((st) => {\n    return getHighestLocation(st) === common_locLevel;\n  });\n\n  //console.log(p1_stays_common, p2_stays_common);\n\n  //at the level of\n\n  //compared each stays, get the least common location level, save to store, if we found bigger score, update\n  for (let i = 0; i < p1_stays_common.length; i++) {\n    let p1_stay = p1_stays_common[i];\n    let p1_stay_range = moment.range(\n      p1_stay.start_date.startOf(\"day\"),\n      p1_stay.end_date.endOf(\"day\")\n    );\n\n    for (let j = 0; j < p2_stays_common.length; j++) {\n      let p2_stay = p2_stays_common[j];\n      let p2_stay_range = moment.range(\n        p2_stay.start_date.startOf(\"day\"),\n        p2_stay.end_date.endOf(\"day\")\n      );\n\n      let is_stays_overlap = p1_stay_range.overlaps(p2_stay_range);\n\n      if (is_stays_overlap) {\n        let overlapDur = p1_stay_range.intersect(p2_stay_range).diff(\"days\");\n\n        if (overlapDur <= 7) {\n          //need to find, at which location level they were overlap\n          //check the deepest one\n\n          let loc_comm_score = getOverlapLocationLevel(p1_stay, p2_stay);\n\n          if (p1 === \"P-13\" && p2 === \"P-18\") {\n            //console.log(\"???\", is_stays_overlap);\n            //console.log(\"+++\", overlapDur, \"days\");\n            // console.log(loc_comm_score);\n            // console.log(\n            //   \"p1\",\n            //   p1_stay.hospital_id,\n            //   p1_stay.ward_id,\n            //   p1_stay.bay_id,\n            //   p1_stay.bed_id\n            // );\n            // console.log(\n            //   \"p2\",\n            //   p2_stay.hospital_id,\n            //   p2_stay.ward_id,\n            //   p2_stay.bay_id,\n            //   p2_stay.bed_id\n            // );\n          }\n          if (loc_comm_score > scoreOverlap) {\n            scoreOverlap = loc_comm_score;\n          }\n        }\n      }\n    }\n  }\n  return scoreOverlap;\n  //SCORING: 1: hospital, 2: ward, 3: bay, 4: bed\n}\n","/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/construct_cge.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/construct_cathai.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/algorithm/construct_mcg.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/chart_barplot_all.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/model/stayList_prop.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_select_samples.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/util_snpDist.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_snpDist_bar.js",[],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_select_charts.js",["337"],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_snpDist_drawCharts.js",["338","339","340"],"/Volumes/DATA/BUDI/PhD_THESIS/chapter_graphSNP/APP/graph-snp/src/page_snpDistance/comp_snpDist_boxplot.js",[],{"ruleId":"341","replacedBy":"342"},{"ruleId":"343","replacedBy":"344"},{"ruleId":"345","severity":1,"message":"346","line":6,"column":16,"nodeType":"347","messageId":"348","endLine":6,"endColumn":25},{"ruleId":"345","severity":1,"message":"349","line":11,"column":7,"nodeType":"347","messageId":"348","endLine":11,"endColumn":13},{"ruleId":"345","severity":1,"message":"350","line":19,"column":9,"nodeType":"347","messageId":"348","endLine":19,"endColumn":13},{"ruleId":"351","severity":1,"message":"352","line":76,"column":6,"nodeType":"353","endLine":76,"endColumn":26,"suggestions":"354"},{"ruleId":"345","severity":1,"message":"355","line":14,"column":10,"nodeType":"347","messageId":"348","endLine":14,"endColumn":30},{"ruleId":"345","severity":1,"message":"356","line":15,"column":10,"nodeType":"347","messageId":"348","endLine":15,"endColumn":23},{"ruleId":"345","severity":1,"message":"357","line":61,"column":9,"nodeType":"347","messageId":"348","endLine":61,"endColumn":29},{"ruleId":"345","severity":1,"message":"358","line":91,"column":9,"nodeType":"347","messageId":"348","endLine":91,"endColumn":22},{"ruleId":"351","severity":1,"message":"359","line":112,"column":6,"nodeType":"353","endLine":112,"endColumn":26,"suggestions":"360"},{"ruleId":"351","severity":1,"message":"361","line":125,"column":6,"nodeType":"353","endLine":125,"endColumn":27,"suggestions":"362"},{"ruleId":"351","severity":1,"message":"363","line":134,"column":6,"nodeType":"353","endLine":134,"endColumn":31,"suggestions":"364"},{"ruleId":"351","severity":1,"message":"363","line":166,"column":6,"nodeType":"353","endLine":166,"endColumn":51,"suggestions":"365"},{"ruleId":"351","severity":1,"message":"366","line":184,"column":6,"nodeType":"353","endLine":184,"endColumn":28,"suggestions":"367"},{"ruleId":"351","severity":1,"message":"368","line":223,"column":6,"nodeType":"353","endLine":223,"endColumn":49,"suggestions":"369"},{"ruleId":"351","severity":1,"message":"368","line":259,"column":6,"nodeType":"353","endLine":259,"endColumn":56,"suggestions":"370"},{"ruleId":"345","severity":1,"message":"371","line":520,"column":15,"nodeType":"347","messageId":"348","endLine":520,"endColumn":34},{"ruleId":"345","severity":1,"message":"372","line":95,"column":9,"nodeType":"347","messageId":"348","endLine":95,"endColumn":29},{"ruleId":"345","severity":1,"message":"373","line":2,"column":10,"nodeType":"347","messageId":"348","endLine":2,"endColumn":13},{"ruleId":"351","severity":1,"message":"359","line":69,"column":6,"nodeType":"353","endLine":69,"endColumn":23,"suggestions":"374"},{"ruleId":"351","severity":1,"message":"361","line":79,"column":6,"nodeType":"353","endLine":79,"endColumn":27,"suggestions":"375"},{"ruleId":"351","severity":1,"message":"363","line":108,"column":6,"nodeType":"353","endLine":108,"endColumn":48,"suggestions":"376"},{"ruleId":"345","severity":1,"message":"377","line":111,"column":9,"nodeType":"347","messageId":"348","endLine":111,"endColumn":27},{"ruleId":"378","severity":1,"message":"379","line":182,"column":37,"nodeType":"380","messageId":"381","endLine":182,"endColumn":38},{"ruleId":"345","severity":1,"message":"382","line":13,"column":7,"nodeType":"347","messageId":"348","endLine":13,"endColumn":17},{"ruleId":"345","severity":1,"message":"383","line":5,"column":8,"nodeType":"347","messageId":"348","endLine":5,"endColumn":21},{"ruleId":"345","severity":1,"message":"349","line":10,"column":7,"nodeType":"347","messageId":"348","endLine":10,"endColumn":13},{"ruleId":"345","severity":1,"message":"383","line":9,"column":8,"nodeType":"347","messageId":"348","endLine":9,"endColumn":21},{"ruleId":"345","severity":1,"message":"384","line":15,"column":3,"nodeType":"347","messageId":"348","endLine":15,"endColumn":24},{"ruleId":"345","severity":1,"message":"385","line":14,"column":9,"nodeType":"347","messageId":"348","endLine":14,"endColumn":21},{"ruleId":"345","severity":1,"message":"385","line":11,"column":9,"nodeType":"347","messageId":"348","endLine":11,"endColumn":21},{"ruleId":"345","severity":1,"message":"386","line":15,"column":9,"nodeType":"347","messageId":"348","endLine":15,"endColumn":22},{"ruleId":"345","severity":1,"message":"387","line":16,"column":9,"nodeType":"347","messageId":"348","endLine":16,"endColumn":19},"no-native-reassign",["388"],"no-negated-in-lhs",["389"],"no-unused-vars","'Paragraph' is assigned a value but never used.","Identifier","unusedVar","'moment' is assigned a value but never used.","'lala' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'props.metadata'. Either include it or remove the dependency array.","ArrayExpression",["390"],"'createClusterCSVFile' is defined but never used.","'cricle_svgUrl' is defined but never used.","'graph_typeOfAnalysis' is assigned a value but never used.","'node_size_sel' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'draw' and 'props'. Either include them or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.",["391"],"React Hook useEffect has missing dependencies: 'props' and 'redraw'. Either include them or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.",["392"],"React Hook useEffect has a missing dependency: 'props'. Either include it or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.",["393"],["394"],"React Hook useEffect has missing dependencies: 'graph_layout' and 'props'. Either include them or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.",["395"],"React Hook useEffect has a missing dependency: 'props.graphObject'. Either include it or remove the dependency array.",["396"],["397"],"'prev_selected_nodes' is assigned a value but never used.","'graph_edge_labelSize' is assigned a value but never used.","'Col' is defined but never used.",["398"],["399"],["400"],"'reloadChartHandler' is assigned a value but never used.","no-useless-concat","Unexpected string concatenation of literals.","BinaryExpression","unexpectedConcat","'minDistLut' is assigned a value but never used.","'GraphEdgeList' is defined but never used.","'filterInverseSymEdges' is defined but never used.","'metadata_arr' is assigned a value but never used.","'dataToDisplay' is assigned a value but never used.","'dataColumn' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"401","fix":"402"},{"desc":"403","fix":"404"},{"desc":"405","fix":"406"},{"desc":"407","fix":"408"},{"desc":"409","fix":"410"},{"desc":"411","fix":"412"},{"desc":"413","fix":"414"},{"desc":"415","fix":"416"},{"desc":"417","fix":"418"},{"desc":"405","fix":"419"},{"desc":"420","fix":"421"},"Update the dependencies array to be: [props.metadata, props.selectedNode]",{"range":"422","text":"423"},"Update the dependencies array to be: [draw, graph_isUserReDraw, props]",{"range":"424","text":"425"},"Update the dependencies array to be: [isUserReloadSession, props, redraw]",{"range":"426","text":"427"},"Update the dependencies array to be: [graph_isUserDownloading, props]",{"range":"428","text":"429"},"Update the dependencies array to be: [graph_clusterMethod, graph_isUserClustering, props]",{"range":"430","text":"431"},"Update the dependencies array to be: [graph_isUserRelayout, graph_layout, props]",{"range":"432","text":"433"},"Update the dependencies array to be: [graph_isEdgeScaled, graph_edgeScaleFactor, props.graphObject]",{"range":"434","text":"435"},"Update the dependencies array to be: [graph_isEdgesHideByCutoff, graph_edgesHideCutoff, props.graphObject]",{"range":"436","text":"437"},"Update the dependencies array to be: [draw, isUserDrawChart, props]",{"range":"438","text":"439"},{"range":"440","text":"427"},"Update the dependencies array to be: [snpDistExportFormat, isUserExportSnpDist, props]",{"range":"441","text":"442"},[2080,2100],"[props.metadata, props.selectedNode]",[4606,4626],"[draw, graph_isUserReDraw, props]",[4960,4981],"[isUserReloadSession, props, redraw]",[5264,5289],"[graph_isUserDownloading, props]",[6356,6401],"[graph_clusterMethod, graph_isUserClustering, props]",[6879,6901],"[graph_isUserRelayout, graph_layout, props]",[7894,7937],"[graph_isEdgeScaled, graph_edgeScaleFactor, props.graphObject]",[8883,8933],"[graph_isEdgesHideByCutoff, graph_edgesHideCutoff, props.graphObject]",[2443,2460],"[draw, isUserDrawChart, props]",[2669,2690],[3405,3447],"[snpDistExportFormat, isUserExportSnpDist, props]"]